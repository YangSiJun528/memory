2024/7/16 읽기 시작

- 읽기 시작한 이유
	- f-lab 멘토링 중 멘토님이 추천해 주심
	- 옮긴이가 자작 OS나 레트로 개발? 같은 것들에 관심이 많으시고, 멘토님이랑 친분도 있으셨다고 한다.
	- 이전에 nand2tetris를 개발하면서 CS 전반적인 것들에 대한 지식을 얻을 수 있었는데, nand2tetirs 책은 3~400 페이지 정도밖에 안되고, 책도 작아서 OS 자체에 대한 정보는 없다시피 했다.
		- 이 경험을 통해 내가 직접 무언가를 만드는 것을 좋아한다는 걸 알게 되었고, (야크 털 깍기라는 말도 있다.) OS 역시 직접 구현하면서 만들고 싶은 욕심이 있다.
	- 옮긴이(박주항)님이 진짜 OS에 진심인것 같긴 한게, https://wikidocs.net/164069 << 이런 것도 쓰셨다.
		- 여기에 한국어 지원하는 것도 있음.
	- 7/19 추가
		- 오늘(어제부터 오늘 새벽까지) 회사 사람들이랑 아는 시니어분이랑 회식하면서 이야기했는데,
			- 내가 OS 구현하는 책 읽고 있다니까, 그것보다는 우분투 깔아서 커널 업그레이드하고, 웹서버 띄워보고 하는게 훨 도움 많이된다고 하셨다.
				- (약간 단순 취미나 재미로 개발하는게 아니라 업으로 하는걸 기준으로 말씀하시는 분 같음.)
			- 당연히 맞는 말인데, 그 분도 마인드(스타트업, 주니어 친화적?)가 좋으셔서 좀 이 책을 읽는게 맞을지 고민해봤다.
			- 근데 음... 그래도 나는 이게 재밌다. 업으로 도움 크게 안되도, 다른 사람은 이 시간에 자기개발하고 있더라도, 그냥 레고처럼 내가 만드는거 보고 돌아가기만 해도 재밌다.
			- 물론 성장 관점에서 좋지 않은건 사실이라, 성장을 위한 다른 공부를 해야 하는건 맞음....

- 목차 미리보고 든 생각
	- 30일을 목표로 만들어진 것 같은데, 나는 퇴근하면 짬내서 하는거라 쉽지 않을 것 같다.
	- 생각보다 커널이 아니라 GUI 구현 부분이 많다. (사용할 수 있는 운영체제를 만드는거니까)
	- OS, 특히 커널을 배우기에는 조금 부족할 수도 있어 보인다.
		- 대신 OS 이해도는 확실히 오를 것 같음.
	- 보니까 가상 메모리랑 공유 메모리는 없는데, 이게 약간 아쉽긴 함.

- 0장 - OS를 개인이 만들 수 있다고?
	- 모놀리식 커널(Monolithic kernel), 마이크로 커널(Micro kernel)이라는 모르는 내용이 나와서 찾아봄.
		- 모놀리식 커널: 입출력, 드라이버, 네트워크 등을 커널과 동일한 메모리에 관리하는 거
		- 마이크로 커널: 최소한의 기능만 커널에서 제공하는 것. 다른 기능은 유저 레벨에서 동작하는 듯?
	- 리얼 타임성도 몰라서 찾아봄
		- Real Time Operating System를 말하는 것 같은데, 
			- > CPU 시간 관리 부분에 초점을 맞추어 설계되었다.
			- > RTC(real-time computing)을 보장하는 것을 목표로 한다.
		- 아마 RTC 말하는 것 같음.
	- 저자는 os의 정의는 명확하게 정해져있지 않다고 한다.
	- 대신 국룰같은게 있다면 아래 3가지 역할
		- 하드웨어 인터페이스
		- 사용자 인터페이스
		- 하드웨어 자원 분배
	- 마우스의 자원 분배를 설명하는 부분. (p.32)가 인상깊었는데
		- 마우스는 자원을 느리게 먹고 드물지만 빠르게 반응해야 사람들이 답답하게 생각하지 않는다.
		- 반대로 동영상 인코딩은 자원을 많이 먹고 길게 동작하지만 중간에 멈춰도 상관 없다.
		- 작업에 따라 우선순위가 다르다는 내용.
	- 같은 인터페이스를 가지면 구현체가 달라도 된다. OS도 마찬가지인데,
		- OS 인터페이스로 POSIX(Portable Operating System Interface)가 유명하다고 하다.
			- 구글링해보니까 이걸 지키면 UINX-like 하다고 하는듯?
		- 다만 책 강의는 안지킨다고 함
			- 나중에 직접 구현해보면 함 POSIX 표준 지켜보기
	- 어떻게 개발하는지 설명하는데
		- 개발 컴퓨터 환경을 설명하는데, 나는 맥밖에 없음...
		- 특히 인텔 환경이라 가상머신 써야하는데, 음... 맥북 m1 에어라 좀...
		- 노트북 싼거 하나 사야하나? - 가상머신 돌리는 인텔 용으로...
	- 36.p에서 직접 생각해보면서 구현해보면 더 깊이 이해할 수 있다고 하는데 진짜 동의하긴 함.
		- 나도 지금 OS 구현하고 있으니까...
		- -> 나중에 안건데 잘못 이해한거였음.
			- "사경"이라고 소스코드 복붙 대신 직접 하나하나 치는걸 이야기하는 거였음.
			- 뭐 그래도 나중에 내가 착각했던 의미인 직접 수정해보는 것이 깊게 이해했다는 증거(62.p)라는 말을 함.
	- 나머지는 목차 설명하는데
		- 나중에 공부하다가 중간에 어떤 순으로 되는지 궁금하면 보면 될듯?

- 개발 환경 미리 찾아봄
	- 책에서는 윈도우 WSL 아니면 우분투 환경에서 쓰라고 하는데,
	- 구글링해보니 도커를 사용해서 편리하게 우분투 개발환경을 구성하는 방법을 알려준다.
	- 근데 그 개발환경 자체가 x86 환경이라, m1에서는 성능 저하가 있을 수 있다고 한다.
	- 참고한 글 링크
		- https://zenn.dev/sarisia/articles/6b57ea835344b6#fn-7a4e-1 << 누군가 도커로 하는 법을 정리한 글
			- https://github.com/sarisia/mikanos-docker << 설명하는 깃헙 프로젝트
		- https://zenn.dev/karaage0703/articles/1bdb8930182c6c << 저자가 위 글을 보고 추가로 정리해준 내용
		- https://wikidocs.net/164069 << 도커로 가능하다는 걸 알게해준 이 책 옮긴이의 WikiDocs 글

- 1장 - PC의 구조와 HelloWorld
	- 요약: UEFI BIOS에서 동작하는 UEFI 어플리케이션 만들기 + 앞으로 실습 환경 가볍게 테스트하기
		- 근데 나는 아직 우분투 노트북(본가에서 택배로 오는 중...)이 없어서 일단 글만 읽음.
	- 더 긴 요약
		- 바이너리 파일 에디터를 사용해 x86 환경에서 실행 가능한 "실행 가능 파일"을 만든다.
		- 여러 방법(우분투, WSL 에서 진짜 PC or QEMU로 실행하기)으로 실행해본다.
	- 정리
		- 실행 가능 파일 : 책에서 구분하는, 컴퓨터 수행 가능한 파일
			- 스크립트: 인터프리터를 사용하여 동작 - Bash, Python 등
			- 기계어: 컴파일러가 만든 기계어로 된 실행 가능한 파일
		- BIOS
			- Basic Input/Output System
			- 기본적인 I/O 기능을 제공한다. OS(부트로더)를 로드하는 역할
		- UEFI BIOS
			- 최근? 표준화 된 BIOS. 이전 BIOS는 거의 사용하지 않는다.
		- UEFI 어플리케이션:
			- UEFI 환경에서 동작하는 어플리케이션. 1장에서 만든 파일이 해당된다.
			- USC-2, PE(책에선 윈도우랑 UEFI용은 약간 달라서 링크 옵션을 다르게 줘야 한다고 함)를 사용한다.
			- C언어와 라이브러리를 사용해 구현 가능하다.
		- USC-2: 유니코드 초기 버전. [관련 링크](https://www.ibm.com/docs/ko/i/7.5?topic=unicode-ucs-2-its-relationship-utf-16)
		- PE, COFF, ELF - 단, 책에서는 HRB라는 독자 규격을 사용한다. (UEFI 개발 외에는 사용 안할듯?)
			- PE: 윈도우 표준 실행 가능 파일 형식
			- COFF: 윈도우용 오브젝트 파일 형식, 중간 파일 형식 - 링크 전 파일 형식
			- ELF: 리눅스 표준 표현 방식, 중간 표현과 실행 가능을 둘 다 수행
			- 공통점: 기계어로 컴파일 됨, x86-64 환경
			- 차이점: 내부 표현 방식
		- UEFI BIOS 동작 흐름
			- 처음 PC가 켜지면 ROM에 저장된 BIOS가 바로 실행 가능한 환경이 구성되어 있음.
			- PC 본체, 주변기기 초기화 -> 실행 가능 파일 탐색 -> 실행 가능 파일(BIOS 어플리케이션, 주로 OS의 부트로더) 메모리 로드 -> 실행 가능 파일 실행
		- 따로 정리까지는 안하는데 다룬 책에서 내용.
			- 비트, 바이트, 2/10/16진수, 체크썸, 바이너리 파일 에디터, QEMU, 엔디언, Unicode
	- 인상깊은 부분
		- 뭔가 생소하거나 신기한게 많이 보인다.
		- `dmesg` 명령어를 사용해서 USB를 꽂을 때 나오는 커널 로그?를 읽어서 USB의 이름을 찾는다거나.
		- 바이너리 파일을 책 내용과 맞게 잘 작성했는지 확인하기 위해  CheckSum을 수행한다거나.
		- QEMU라거나..