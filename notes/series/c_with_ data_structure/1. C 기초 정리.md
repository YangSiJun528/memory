
확실히 저수준에 대한 이해가 있는 상태에서 다시 배우니까 이해가 잘 되고 재밌다. 점프 테이블이 이제 이해된다거나, 형변환 시 원본 데이터에 대한 궁금증이 생긴다거나...

# 유용한 사이트

정리할때도 참고함

- [씹어먹는 C 언어 시리즈](https://modoocode.com/231): C 언어 배울 때, 주로 참고한 사이트
- [C CheatSheet](https://quickref.me/c.html): 문법을 어느정도 안다는 가정 하에 빠르게 찾아보기 좋음.
- [마이크로소프트 C 참고 문서](https://learn.microsoft.com/ko-kr/cpp/c-language/organization-of-the-c-language-reference?view=msvc-170): 정확한 C언어 문법 참고를 웹으로 하고 싶을때 사용, 단 C89 기준이고, Microsoft의 확장 기능이 서술되어 있음을 주의.
- [나무위키 C언어 문법](<https://namu.wiki/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)/%EB%AC%B8%EB%B2%95>): 한글로 된 확인하기 쉬운 C문법
- [Reading C](http://unixwiz.net/techtips/reading-cdecl.html): C언어 복잡한 데이터 읽는 법

# 변수, 타입, printf

```c
#include <stdio.h>  
  
// 구글 C++ 스타일 가이드 번역 (C 가이트는 잘 없더라)  
// https://jongwook.kim/google-styleguide/trunk/cppguide.xml#%EC%A3%BC%EC%84%9D  
  
int add(int a, int b); // 함수 프로토타입, 컴파일러에게 함수의 존재를 알림  
  
/*  
 * 긴 주석, 아마 함수의 명세에 대한 설명을 작성할 때 주로 사용할 듯?  
 * // 는 코드 중간에서 일부 문맥 설명할 때나 쓰고...  
 */int main(void) { // void는 함수의 파라미터/리턴 타입이 없음을 지정, 혹은 모든 타입을 받는 포인터 타입 지정 시 사용  
    // 변수 선언 및 초기화  
    int integer_var = 42;           // 정수형 변수  
    unsigned int uint_var = 42;     // unsigned(부호 없는) 정수형 변수  
    float float_var = 3.14f;        // float, f를 붙여 4byte 리터럴 값임을 명시  
    double double_var = 3.141592;   // double  
    char char_var = 'A';            // 문자형 변수, ' 사용  
    char str_var[] = "Hello, C!";   // 문자열 변수, " 사용  
    int *ptr_var = &integer_var;  
  
  
    // 변수 출력  
    printf("Integer: %d\n", integer_var);   // 정수형 변수 출력 (%d)    printf("Integer: %d\n", uint_var);      // unsigned 정수형 변수 출력 (%d)    printf("Float: %f\n", float_var);       // float (%f)  
    printf("Double: %lf\n", double_var);    // double (%lf)  
    printf("Character: %c\n", char_var);    // 문자형 변수 출력 (%c)    printf("String: %s\n", str_var);        // 문자열 변수 출력 (%s)    printf("Address: %p\n", ptr_var);       // 포인터가 참조하는 주소 (%p)  
    // 함수 호출  
    int result = add(5, 3);                // 함수 호출: add 함수에 5와 3을 인수로 전달  
    printf("Result of add(5, 3): %d\n", result); // 함수 결과 출력  
  
    return 0; // 프로그램 종료 상태를 반환 0은 성공, 1은 실패  
}  
  
// 함수 정의  
int add(int a, int b) {  
    return a + b;  
}
```

#### 상수

변수 선언문 앞에 `const`를 추가하여 상수로 만들 수 있다.

상수는 선언과 함께 초기화가 필수이며, 수정할 수 없다. (수정 시 컴파일러 에러 발생)

#### 변수의 선언과 초기화

변수 선언 이후, 초기화를 하지 않으면 쓰레기 값이 남아있는 상태이다.

초기화를 통해 값을 지정해주어야 한다.

이 경우 컴파일러가 경고를 띄울 수 있다.

#### Bool 타입

C99 부터 [bool 타입을 지원](https://medium.com/@kyle_seongwoo_jun/c%EC%97%90%EC%84%9C-bool-%ED%83%80%EC%9E%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-105ecaf1db02)한다.

`_Bool`이라는 이름이 있는데, 일반적인 타입 이름과 달라서 `#include <stdbool.h>`를 사용해서 `bool`이라는 이름으로 사용할수도 있다.

그 전에는 0을 거짓, 나머지 값은 참으로 간주했다.

# 산술, 비트, 대입 연산자

(GPT의 도움을 받음)

우선순위와 같은 부분이 중요하긴 한데, 애매한 부분은 그냥 괄호를 사용하는 식으로 할 예정. 어차피 의미없는 괄호라면 IDE가 경고해주기 때문에... (그리고 그런 애매한 부분은 괄호 써서 확실하게 하는게 좋다고 생각함)

비트 연산이 조금 생소하긴 한데, 이해 못하는 정도는 아니고, java에서도 쓰긴 하니까 따로 정리는 안함.

- **산술 연산자**:
    - 덧셈 (`+`)
    - 뺄셈 (`-`)
    - 곱셈 (`*`)
    - 나눗셈 (`/`)
    - 나머지 (`%`)
    - 증감 연산자 (`++`, `--`)
- **비트 연산자**:
    - AND (`&`)
    - OR (`|`)
    - XOR (`^`)
    - NOT (`~`)
    - 왼쪽 시프트 (`<<`)
    - 오른쪽 시프트 (`>>`)
- **대입 연산자**:
    - 대입 (`=`)
    - 더하기 후 대입 (`+=`)
    - 빼기 후 대입 (`-=`)
    - 곱하기 후 대입 (`*=`)
    - 나누기 후 대입 (`/=`)
    - 나머지 후 대입 (`%=`)
    - AND 후 대입 (`&=`)
    - OR 후 대입 (`|=`)
    - XOR 후 대입 (`^=`)
    - 왼쪽 시프트 후 대입 (`<<=`)
    - 오른쪽 시프트 후 대입 (`>>=`)

```c
#include <stdio.h>

int main() {
    // 산술 연산자
    int a = 10;
    int b = 5;
    int result;

    // 덧셈
    result = a + b;  // result = 15
    printf("a + b = %d\n", result);

    // 뺄셈
    result = a - b;  // result = 5
    printf("a - b = %d\n", result);

    // 곱셈
    result = a * b;  // result = 50
    printf("a * b = %d\n", result);

    // 나눗셈
    result = a / b;  // result = 2
    printf("a / b = %d\n", result);

    // 나머지 연산
    result = a % b;  // result = 0
    printf("a %% b = %d\n", result);

    // 증감 연산자
    a++;  // a = 11
    printf("a++ = %d\n", a);

    b--;  // b = 4
    printf("b-- = %d\n", b);

    // 비트 연산자
    int x = 6;  // 6 = 00000110 in binary
    int y = 3;  // 3 = 00000011 in binary

    // AND
    result = x & y;  // result = 2 (00000010 in binary)
    printf("x & y = %d\n", result);

    // OR
    result = x | y;  // result = 7 (00000111 in binary)
    printf("x | y = %d\n", result);

    // XOR
    result = x ^ y;  // result = 5 (00000101 in binary)
    printf("x ^ y = %d\n", result);

    // NOT
    result = ~x;  // result = -7 (11111001 in binary, two's complement)
    printf("~x = %d\n", result);

    // 왼쪽 시프트
    result = x << 1;  // result = 12 (00001100 in binary)
    printf("x << 1 = %d\n", result);

    // 오른쪽 시프트
    result = x >> 1;  // result = 3 (00000011 in binary)
    printf("x >> 1 = %d\n", result);

    // 대입 연산자
    int z = 0;

    // 더하기 후 대입
    z += a;  // z = z + a (z = 0 + 11, z = 11)
    printf("z += a = %d\n", z);

    // 빼기 후 대입
    z -= b;  // z = z - b (z = 11 - 4, z = 7)
    printf("z -= b = %d\n", z);

    // 곱하기 후 대입
    z *= a;  // z = z * a (z = 7 * 11, z = 77)
    printf("z *= a = %d\n", z);

    // 나누기 후 대입
    z /= b;  // z = z / b (z = 77 / 4, z = 19)
    printf("z /= b = %d\n", z);

    // 나머지 후 대입
    z %= a;  // z = z % a (z = 19 % 11, z = 8)
    printf("z %%= a = %d\n", z);

    // AND 후 대입
    z &= x;  // z = z & x (z = 8 & 6, z = 0)
    printf("z &= x = %d\n", z);

    // OR 후 대입
    z |= y;  // z = z | y (z = 0 | 3, z = 3)
    printf("z |= y = %d\n", z);

    // XOR 후 대입
    z ^= x;  // z = z ^ x (z = 3 ^ 6, z = 5)
    printf("z ^= x = %d\n", z);

    // 왼쪽 시프트 후 대입
    z <<= 2;  // z = z << 2 (z = 5 << 2, z = 20)
    printf("z <<= 2 = %d\n", z);

    // 오른쪽 시프트 후 대입
    z >>= 1;  // z = z >> 1 (z = 20 >> 1, z = 10)
    printf("z >>= 1 = %d\n", z);

    return 0;
}
```


# if, for, while, switch, goto

자바랑 크게 다르지 않고, 간단한 사용법은 [C CheatSheet](https://quickref.me/c.html)가 잘 되어있어서 생략.

공부하면서 필요하다고 생각한 부분만 메모

- 논리 연산자
	- AND: `&&`
	- OR: `||`
	- **`&` 대신 `&&`를 쓰는 이유**
		- `&`는 확실하게 비트 `AND` 연산 외의 경우에는 (유효하더라도) 사용하지 않는게 좋다.
		- Short Circuit Evaluation 떄문인데, 더 이상 논리를 확인하지 않고 결과를 알 수 있는 경우 생략한다. `&`는 이 SCE를 지원하지 못한다. (정확한 계산 결과가 필요하기 때문)
- **`switch` 문이 필요한 이유**
	- `if-else`보다 성능이 더 좋은 경우가 있다.
	- `if-else`의 경우 매 블록마다 비교 연산(CMP)이 발생한다. 최악의 경우, 모든 조건을 평가한다.
	- `switch`문은 `jump table`을 사용해서 효율적으로 처리한다. 주어진 값에 따라 해당 로직을 처리하는 주소로 `jump`하기 때문에 case가 아무리 많아져도 효율적으로 처리된다. (한 번의 검사)
	- 이게 가능한 이유는 switch문의 변수 타입이 제한되어 있기 때문이다.
		- 반대로 `if-else`문에 작성하는 조건은 자유롭게 작성할 수 있다.
	- `switch`문이 효율적으로 처리되기 위한 조건
		- 어셈블리어를 설명해야 해서 대충 결론만 설명. 아래 경우가 해당이 안되면 다른 방식으로 최적화 하거나 `if-else` 처럼 처리하기도 함.
		1. 케이스가 상수 값이어야 함: 변수가 들어가면 `jump table`로 최적화가 불가능
		2. 케이스 값이 연속적이거나 범위가 좁아야  함: 값 간의 차이가 크면 `jump table`로 최적화가 비효율적임
	- `if-else`와 `switch` 사용에 대한 개인적인 생각
		- 최적화, 가독성을 위한 제한적인 경우 말고는 `if-else`가 더 좋다고 생각함.
		- `switch`는 들어오는 변수 타입을 제한해 버려서 확장이 어렵기 때문임.
			- `int`나 문자열처럼 제한적인게 확실한 경우면 모를까.
			- 코드를 개발하다보면 여러 조건을 처리하게 되는데, 이런 조건을 작성하는데 제한이 생기는게 좋지 않다고 생각함.
			- 물론 여러 조건을 작성해야 하는 경우 자체가 코드 품질을 떨어트리거나, 설계의 오류가 될 수도 있다고 생각하는데
				- 실무에서는 그런 돌발 상황을 처리해야 할 때가 있을꺼라 생각함.

###### goto문 사용법

goto문을 정리할 필요가 있나 싶긴 한데, 그래도 나중에 궁금해질까봐 간단하게 정리함.

`레이블이름:`으로 레이블을 정의, `goto 레이블이름`으로 이동 가능하다.

단, 가독성, 유지보수성, 구조적 프로그래밍 원칙 위반 등의 문제로 거의 사용하지 않는다.

```c
#include <stdio.h>

int main() {
    int i = 0;

loop:
    printf("%d\n", i);
    i++;

    if (i < 5)
        goto loop;

    return 0;
}
```

# 형변환(Casting)

`(타입이름) 변수 이름`을 사용해서 캐스팅 할 수 있다.

서로 다른 구조체/공용체(union) 사이의 형변환이나 상수 포인터의 형변환 등을 제외하고 대부분의 타입 간에서 형변환이 수행 가능하다.

- 암시적 형변환
	- 형변환(캐스팅) 기능을 사용하지 않는 것.
	- 컴파일 에러가 발생하지는 않지만, 의도하지 않는 값이 들어갈 수 있으므로 작은 크기의 데이터를 큰 데이터로 변환하는 경우 외에는 명시적으로 사용하는걸 권장한다.
	- 기존의 데이터가 손실될 수 있는 경우, IDE나 컴파일러가 경고를 해준다.
- 명시적 형변환
	- `(타입이름) 변수 이름`을 사용한 형변환
- 형변환 시 원본 데이터가 수정되지는 않는다.
	- 임시 변수를 사용하거나, 
	- 데이터를 다른 식으로 해석한다.
		- 4바이트 중 뒤 2바이트만 읽어서 `int`를 `short`로 바꾼다거나 하는 식

# 배열

사이즈가 고정된 정적 배열이다. 선언 시 정해줘야 함.

배열의 크기를 벗어나는 인덱스로 조회하더라도 컴파일 예외가 발생하지 않기 때문에 주의해야한다.

- `타입 배열이름[] = {값 목록1, 2}`
	- 깂 목록 개수만큼 크기가 정해진다.
	- 아니면 다음처럼 사용할 수도 있다.
		- `타입 배열이름[배열 크기] = {값 목록1, 2}`
		- 이러면 0~1번째는 초기화되고, 나머지는 더미 값이 들어간다.
- `타입 배열이름[배열 크기]`
	- 초기화 없이 선언만
- 배열 안에 배열을 집어넣어 N차원 배열을 만들 수 있다.
	- `타입 배열이름[1번째 배열 크기] ... [N번째 크기]`
	- 필요에 따라 초기화를 할 수 있는데,
		- `{{1,3}, {2,4}}` 처럼 중첩해서 사용하거나
		- `{1,3,2,4}` 처럼 힌 줄로 초기화 할 수도 있다. 
		- 어차피 컴파일러 입장에서는 연속된 메모리 공간에 저장되므로 동일하다.

```c
int myNumbers[] = {25, 50, 75, 100};

printf("%d", myNumbers[0]);
// output 25

// Declare an array of four integers:
int myNumbers[4];

// add element
myNumbers[0] = 25;
myNumbers[1] = 50;
myNumbers[2] = 75;
myNumbers[3] = 100;
```

#### C99이후 지원하는 가변 배열

배열 선언 시 크기를 런타임에 정하게 할 수 있다.

`scanf`로 입력받은 만큼의 크기를 선언할 수도 있음.

단, 어떤 위치에서 사용되는 Stack 영역에 정의되기 때문에 스택 오버플로우가 발생하지 않게, 크기를 잘 고려해야 한다.

- 배열의 메모리 위치
	- 정적/전역 배열: Data
	- 동적 배열(`malloc`같은거 사용 시): Heap
	- 지역(함수 내부)/동적 배열: Stack

# 포인터



# GPT
### [GPT 사용] C언어 함수 호출 과정 어셈블리어로 이해하기 

ARM64 어셈블리어 사용함. (mac m1을 사용하기 때문)

어차피 공통적인 흐름 정도를 알아보기 위한 거니까 ㄱㅊ

```c
#include <stdio.h>

int add(int a, int b);

int main(void) {
    int a = 2;
    int b = 12;

    printf("Result of add(a, b): %d\n", add(a, b));

    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

다음 코드를 CLion의 기능을 사용해 어셈블리어로 번역했다. (`-std=gnu11 -arch arm64 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.3.sdk`)
```arm
_main:
	sub	sp, sp, #48             // 스택 포인터를 48바이트 감소시켜 스택 프레임을 설정합니다.
	stp	x29, x30, [sp, #32]     // 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택에 저장합니다.
	add	x29, sp, #32            // 현재 스택 포인터에 32를 더해 프레임 포인터(x29)를 설정합니다.
	mov	w8, #0                  // w8 레지스터에 0을 저장합니다.
	str	w8, [sp, #16]           // w8(0)을 sp+16 위치에 저장합니다.
	stur	wzr, [x29, #-4]     // wzr(0)을 x29-4 위치에 저장합니다.
	mov	w8, #2                  // w8 레지스터에 2를 저장합니다.
	stur	w8, [x29, #-8]      // w8(2)을 x29-8 위치에 저장합니다. (a = 2)
	mov	w8, #12                 // w8 레지스터에 12를 저장합니다.
	stur	w8, [x29, #-12]     // w8(12)을 x29-12 위치에 저장합니다. (b = 12)
	ldur	w0, [x29, #-8]      // x29-8 위치에서 값을 로드하여 w0 레지스터에 저장합니다. (a 값 로드)
	ldur	w1, [x29, #-12]     // x29-12 위치에서 값을 로드하여 w1 레지스터에 저장합니다. (b 값 로드)
	bl	_add                    // add 함수를 호출합니다.
	mov	x9, sp                  // 스택 포인터 값을 x9 레지스터에 저장합니다.
	mov	x8, x0                  // x0 레지스터의 값을 x8 레지스터에 저장합니다.
	str	x8, [x9]                // x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
	adrp	x0, l_.str@PAGE     // 문자열 리터럴 l_.str의 페이지 주소를 x0 레지스터에 로드합니다.
	add	x0, x0, l_.str@PAGEOFF  // 문자열 리터럴 l_.str의 페이지 오프셋을 x0 레지스터에 더합니다.
	bl	_printf                 // printf 함수를 호출합니다.
	ldr	w0, [sp, #16]           // sp+16 위치에서 값을 로드하여 w0 레지스터에 저장합니다.
	ldp	x29, x30, [sp, #32]     // 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
	add	sp, sp, #48             // 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

_add:
	sub	sp, sp, #16             // 스택 포인터를 16바이트 감소시켜 스택 프레임을 설정합니다.
	str	w0, [sp, #12]           // w0 레지스터의 값을 sp+12 위치에 저장합니다.
	str	w1, [sp, #8]            // w1 레지스터의 값을 sp+8 위치에 저장합니다.
	ldr	w8, [sp, #12]           // sp+12 위치에서 값을 로드하여 w8 레지스터에 저장합니다.
	ldr	w9, [sp, #8]            // sp+8 위치에서 값을 로드하여 w9 레지스터에 저장합니다.
	add	w0, w8, w9              // w8과 w9의 값을 더하여 w0 레지스터에 저장합니다.
	add	sp, sp, #16             // 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

	.asciz	"Result of add(a, b): %d\n" // 문자열 리터럴
```

##### **중요한 부분 정리**

- main 함수에서부터 Call Stack을 사용하여 처리하는 모습을 볼 수 있다.    

- `add` 함수 호출 시
	- Stack Frame을 정의하고, `w0`, `w1`로 전달받은 매개변수를 Stack에 저장한다.
		- 미리 Stack Pointer를 증가시켜 사용할 Frame(매개변수, Callee 주소, 지역변수)을 공간을 선언한다.   
	- Stack에 저장된 변수를 가져와서 `w8`, `w9`에 저장하고 연산 결과를 `w0`에 저장한다.
	- 이후 SP를 낮춘 후 리턴한다.

- 파일 내 존재하지 않는 함수인 `printf`는 `bl`이라는 명령어로 호출한다.

###### 매개변수 전달 시 Stack에 저장하지 않은 이유
GTP 피셜로는 ARM의 경우 매개변수 4개까지는 함수 호출 시 레지스터를 사용한다고 한다. (반환 시에는 값이 하나이므로 마찬가지로 레지스터를 사용한다. x86의 경우에도 2개까지는 레지스터 (ECX, EDX)를 통해서 전달한다고 한다.)

4개를 넘어가면 스택을 사용한다고 한다.

#### GPT의 해설

##### 함수 호출 전후의 프레임 처리
1. **메인 함수 스택 프레임 설정**:
    - `sub sp, sp, #48`:
        - 스택 포인터를 48바이트 감소시켜 새로운 스택 프레임을 설정합니다. 이 공간은 지역 변수와 함수 호출의 저장 공간으로 사용됩니다.
    - `stp x29, x30, [sp, #32]`:
        - 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택의 sp+32 위치에 저장합니다. 이는 함수 호출이 끝난 후 원래의 호출 프레임으로 돌아가기 위해 필요합니다.
    - `add x29, sp, #32`:
        - 현재 스택 포인터 값에 32를 더하여 새로운 프레임 포인터(x29)를 설정합니다. 이제 x29는 현재 함수의 프레임 베이스 포인터가 됩니다.
2. **변수 초기화**:
    - `mov w8, #2` 및 `stur w8, [x29, #-8]`:
        - w8 레지스터에 2를 저장하고, 이를 x29-8 위치에 저장합니다. 이는 변수 `a`를 초기화하는 과정입니다.
    - `mov w8, #12` 및 `stur w8, [x29, #-12]`:
        - w8 레지스터에 12를 저장하고, 이를 x29-12 위치에 저장합니다. 이는 변수 `b`를 초기화하는 과정입니다.
3. **함수 호출 준비**:
    - `ldur w0, [x29, #-8]` 및 `ldur w1, [x29, #-12]`:
        - x29-8 위치의 값을 w0 레지스터에 로드하고, x29-12 위치의 값을 w1 레지스터에 로드합니다. 이는 함수 `add`의 인수 `a`와 `b`를 준비하는 과정입니다.
    - `bl _add`:
        - `add` 함수를 호출합니다. 이때 `w0`와 `w1` 레지스터의 값이 함수의 인수로 전달됩니다.

##### `add` 함수의 스택 프레임 설정 및 해제
4. **`add` 함수 스택 프레임 설정**:
    - `sub sp, sp, #16`:
        - 스택 포인터를 16바이트 감소시켜 새로운 스택 프레임을 설정합니다.
    - `str w0, [sp, #12]` 및 `str w1, [sp, #8]`:
        - `w0` 레지스터의 값을 sp+12 위치에 저장하고, `w1` 레지스터의 값을 sp+8 위치에 저장합니다. 이는 `add` 함수의 인수 `a`와 `b`를 스택에 저장하는 과정입니다.
5. **변수 값 로드 및 덧셈 연산**:
    - `ldr w8, [sp, #12]` 및 `ldr w9, [sp, #8]`:
        - sp+12 위치의 값을 w8 레지스터에 로드하고, sp+8 위치의 값을 w9 레지스터에 로드합니다.
    - `add w0, w8, w9`:
        - w8과 w9의 값을 더하여 w0 레지스터에 저장합니다. 이는 `a + b`의 결과를 계산하는 과정입니다.
6. **`add` 함수의 스택 프레임 해제 및 리턴**:
    - `add sp, sp, #16`:
        - 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다. 이때 결과 값은 `w0` 레지스터에 저장되어 있습니다.

##### `main` 함수의 나머지 처리
7. **printf 호출 준비 및 호출**:
    - `mov x9, sp` 및 `mov x8, x0`:
        - 스택 포인터 값을 x9 레지스터에 저장하고, `add` 함수의 결과 값을 x8 레지스터에 저장합니다.
    - `str x8, [x9]`:
        - x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
    - `adrp x0, l_.str@PAGE` 및 `add x0, x0, l_.str@PAGEOFF`:
        - 문자열 리터럴 l_.str의 페이지 주소와 페이지 오프셋을 x0 레지스터에 로드합니다.
    - `bl _printf`:
        - `printf` 함수를 호출합니다.
8. **메인 함수 스택 프레임 해제 및 리턴**:
    - `ldr w0, [sp, #16]`:
        - sp+16 위치의 값을 w0 레지스터에 로드합니다. (사용되지 않는 코드로 보임)
    - `ldp x29, x30, [sp, #32]`:
        - 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
    - `add sp, sp, #48`:
        - 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다.
