
확실히 저수준에 대한 이해가 있는 상태에서 다시 배우니까 이해가 잘 되고 재밌다. 점프 테이블이 이제 이해된다거나, 형변환 시 원본 데이터에 대한 궁금증이 생긴다거나...

# 유용한 사이트

정리할때도 참고함

- [씹어먹는 C 언어 시리즈](https://modoocode.com/231): C 언어 배울 때, 주로 참고한 사이트
- [C CheatSheet](https://quickref.me/c.html): 문법을 어느정도 안다는 가정 하에 빠르게 찾아보기 좋음.
- [마이크로소프트 C 참고 문서](https://learn.microsoft.com/ko-kr/cpp/c-language/organization-of-the-c-language-reference?view=msvc-170): 정확한 C언어 문법 참고를 웹으로 하고 싶을때 사용, 단 C89 기준이고, Microsoft의 확장 기능이 서술되어 있음을 주의.
- [나무위키 C언어 문법](<https://namu.wiki/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)/%EB%AC%B8%EB%B2%95>): 한글로 된 확인하기 쉬운 C문법
- [Reading C](http://unixwiz.net/techtips/reading-cdecl.html): C언어 복잡한 데이터 읽는 법

# 변수, 타입, printf

```c
#include <stdio.h>  
  
// 구글 C++ 스타일 가이드 번역 (C 가이트는 잘 없더라)  
// https://jongwook.kim/google-styleguide/trunk/cppguide.xml#%EC%A3%BC%EC%84%9D  
  
int add(int a, int b); // 함수 프로토타입, 컴파일러에게 함수의 존재를 알림  
  
/*  
 * 긴 주석, 아마 함수의 명세에 대한 설명을 작성할 때 주로 사용할 듯?  
 * // 는 코드 중간에서 일부 문맥 설명할 때나 쓰고...  
 */int main(void) { // void는 함수의 파라미터/리턴 타입이 없음을 지정, 혹은 모든 타입을 받는 포인터 타입 지정 시 사용  
    // 변수 선언 및 초기화  
    int integer_var = 42;           // 정수형 변수  
    unsigned int uint_var = 42;     // unsigned(부호 없는) 정수형 변수  
    float float_var = 3.14f;        // float, f를 붙여 4byte 리터럴 값임을 명시  
    double double_var = 3.141592;   // double  
    char char_var = 'A';            // 문자형 변수, ' 사용  
    char str_var[] = "Hello, C!";   // 문자열 변수, " 사용  
    int *ptr_var = &integer_var;  
  
  
    // 변수 출력  
    printf("Integer: %d\n", integer_var);   // 정수형 변수 출력 (%d)    printf("Integer: %d\n", uint_var);      // unsigned 정수형 변수 출력 (%d)    printf("Float: %f\n", float_var);       // float (%f)  
    printf("Double: %lf\n", double_var);    // double (%lf)  
    printf("Character: %c\n", char_var);    // 문자형 변수 출력 (%c)    printf("String: %s\n", str_var);        // 문자열 변수 출력 (%s)    printf("Address: %p\n", ptr_var);       // 포인터가 참조하는 주소 (%p)  
    // 함수 호출  
    int result = add(5, 3);                // 함수 호출: add 함수에 5와 3을 인수로 전달  
    printf("Result of add(5, 3): %d\n", result); // 함수 결과 출력  
  
    return 0; // 프로그램 종료 상태를 반환 0은 성공, 1은 실패  
}  
  
// 함수 정의  
int add(int a, int b) {  
    return a + b;  
}
```

#### 상수

변수 선언문 앞에 `const`를 추가하여 상수로 만들 수 있다.

상수는 선언과 함께 초기화가 필수이며, 수정할 수 없다. (수정 시 컴파일러 에러 발생)

#### 변수의 선언과 초기화

변수 선언 이후, 초기화를 하지 않으면 쓰레기 값이 남아있는 상태이다.

초기화를 통해 값을 지정해주어야 한다.

이 경우 컴파일러가 경고를 띄울 수 있다.

#### Bool 타입

C99 부터 [bool 타입을 지원](https://medium.com/@kyle_seongwoo_jun/c%EC%97%90%EC%84%9C-bool-%ED%83%80%EC%9E%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-105ecaf1db02)한다.

`_Bool`이라는 이름이 있는데, 일반적인 타입 이름과 달라서 `#include <stdbool.h>`를 사용해서 `bool`이라는 이름으로 사용할수도 있다.

그 전에는 0을 거짓, 나머지 값은 참으로 간주했다.

# 산술, 비트, 대입 연산자

(GPT의 도움을 받음)

우선순위와 같은 부분이 중요하긴 한데, 애매한 부분은 그냥 괄호를 사용하는 식으로 할 예정. 어차피 의미없는 괄호라면 IDE가 경고해주기 때문에... (그리고 그런 애매한 부분은 괄호 써서 확실하게 하는게 좋다고 생각함)

비트 연산이 조금 생소하긴 한데, 이해 못하는 정도는 아니고, java에서도 쓰긴 하니까 따로 정리는 안함.

- **산술 연산자**:
    - 덧셈 (`+`)
    - 뺄셈 (`-`)
    - 곱셈 (`*`)
    - 나눗셈 (`/`)
    - 나머지 (`%`)
    - 증감 연산자 (`++`, `--`)
- **비트 연산자**:
    - AND (`&`)
    - OR (`|`)
    - XOR (`^`)
    - NOT (`~`)
    - 왼쪽 시프트 (`<<`)
    - 오른쪽 시프트 (`>>`)
- **대입 연산자**:
    - 대입 (`=`)
    - 더하기 후 대입 (`+=`)
    - 빼기 후 대입 (`-=`)
    - 곱하기 후 대입 (`*=`)
    - 나누기 후 대입 (`/=`)
    - 나머지 후 대입 (`%=`)
    - AND 후 대입 (`&=`)
    - OR 후 대입 (`|=`)
    - XOR 후 대입 (`^=`)
    - 왼쪽 시프트 후 대입 (`<<=`)
    - 오른쪽 시프트 후 대입 (`>>=`)

```c
#include <stdio.h>

int main() {
    // 산술 연산자
    int a = 10;
    int b = 5;
    int result;

    // 덧셈
    result = a + b;  // result = 15
    printf("a + b = %d\n", result);

    // 뺄셈
    result = a - b;  // result = 5
    printf("a - b = %d\n", result);

    // 곱셈
    result = a * b;  // result = 50
    printf("a * b = %d\n", result);

    // 나눗셈
    result = a / b;  // result = 2
    printf("a / b = %d\n", result);

    // 나머지 연산
    result = a % b;  // result = 0
    printf("a %% b = %d\n", result);

    // 증감 연산자
    a++;  // a = 11
    printf("a++ = %d\n", a);

    b--;  // b = 4
    printf("b-- = %d\n", b);

    // 비트 연산자
    int x = 6;  // 6 = 00000110 in binary
    int y = 3;  // 3 = 00000011 in binary

    // AND
    result = x & y;  // result = 2 (00000010 in binary)
    printf("x & y = %d\n", result);

    // OR
    result = x | y;  // result = 7 (00000111 in binary)
    printf("x | y = %d\n", result);

    // XOR
    result = x ^ y;  // result = 5 (00000101 in binary)
    printf("x ^ y = %d\n", result);

    // NOT
    result = ~x;  // result = -7 (11111001 in binary, two's complement)
    printf("~x = %d\n", result);

    // 왼쪽 시프트
    result = x << 1;  // result = 12 (00001100 in binary)
    printf("x << 1 = %d\n", result);

    // 오른쪽 시프트
    result = x >> 1;  // result = 3 (00000011 in binary)
    printf("x >> 1 = %d\n", result);

    // 대입 연산자
    int z = 0;

    // 더하기 후 대입
    z += a;  // z = z + a (z = 0 + 11, z = 11)
    printf("z += a = %d\n", z);

    // 빼기 후 대입
    z -= b;  // z = z - b (z = 11 - 4, z = 7)
    printf("z -= b = %d\n", z);

    // 곱하기 후 대입
    z *= a;  // z = z * a (z = 7 * 11, z = 77)
    printf("z *= a = %d\n", z);

    // 나누기 후 대입
    z /= b;  // z = z / b (z = 77 / 4, z = 19)
    printf("z /= b = %d\n", z);

    // 나머지 후 대입
    z %= a;  // z = z % a (z = 19 % 11, z = 8)
    printf("z %%= a = %d\n", z);

    // AND 후 대입
    z &= x;  // z = z & x (z = 8 & 6, z = 0)
    printf("z &= x = %d\n", z);

    // OR 후 대입
    z |= y;  // z = z | y (z = 0 | 3, z = 3)
    printf("z |= y = %d\n", z);

    // XOR 후 대입
    z ^= x;  // z = z ^ x (z = 3 ^ 6, z = 5)
    printf("z ^= x = %d\n", z);

    // 왼쪽 시프트 후 대입
    z <<= 2;  // z = z << 2 (z = 5 << 2, z = 20)
    printf("z <<= 2 = %d\n", z);

    // 오른쪽 시프트 후 대입
    z >>= 1;  // z = z >> 1 (z = 20 >> 1, z = 10)
    printf("z >>= 1 = %d\n", z);

    return 0;
}
```


# if, for, while, switch, goto

자바랑 크게 다르지 않고, 간단한 사용법은 [C CheatSheet](https://quickref.me/c.html)가 잘 되어있어서 생략.

공부하면서 필요하다고 생각한 부분만 메모

- 논리 연산자
	- AND: `&&`
	- OR: `||`
	- **`&` 대신 `&&`를 쓰는 이유**
		- `&`는 확실하게 비트 `AND` 연산 외의 경우에는 (유효하더라도) 사용하지 않는게 좋다.
		- Short Circuit Evaluation 떄문인데, 더 이상 논리를 확인하지 않고 결과를 알 수 있는 경우 생략한다. `&`는 이 SCE를 지원하지 못한다. (정확한 계산 결과가 필요하기 때문)
- **`switch` 문이 필요한 이유**
	- `if-else`보다 성능이 더 좋은 경우가 있다.
	- `if-else`의 경우 매 블록마다 비교 연산(CMP)이 발생한다. 최악의 경우, 모든 조건을 평가한다.
	- `switch`문은 `jump table`을 사용해서 효율적으로 처리한다. 주어진 값에 따라 해당 로직을 처리하는 주소로 `jump`하기 때문에 case가 아무리 많아져도 효율적으로 처리된다. (한 번의 검사)
	- 이게 가능한 이유는 switch문의 변수 타입이 제한되어 있기 때문이다.
		- 반대로 `if-else`문에 작성하는 조건은 자유롭게 작성할 수 있다.
	- `switch`문이 효율적으로 처리되기 위한 조건
		- 어셈블리어를 설명해야 해서 대충 결론만 설명. 아래 경우가 해당이 안되면 다른 방식으로 최적화 하거나 `if-else` 처럼 처리하기도 함.
		1. 케이스가 상수 값이어야 함: 변수가 들어가면 `jump table`로 최적화가 불가능
		2. 케이스 값이 연속적이거나 범위가 좁아야  함: 값 간의 차이가 크면 `jump table`로 최적화가 비효율적임
	- `if-else`와 `switch` 사용에 대한 개인적인 생각
		- 최적화, 가독성을 위한 제한적인 경우 말고는 `if-else`가 더 좋다고 생각함.
		- `switch`는 들어오는 변수 타입을 제한해 버려서 확장이 어렵기 때문임.
			- `int`나 문자열처럼 제한적인게 확실한 경우면 모를까.
			- 코드를 개발하다보면 여러 조건을 처리하게 되는데, 이런 조건을 작성하는데 제한이 생기는게 좋지 않다고 생각함.
			- 물론 여러 조건을 작성해야 하는 경우 자체가 코드 품질을 떨어트리거나, 설계의 오류가 될 수도 있다고 생각하는데
				- 실무에서는 그런 돌발 상황을 처리해야 할 때가 있을꺼라 생각함.

###### goto문 사용법

goto문을 정리할 필요가 있나 싶긴 한데, 그래도 나중에 궁금해질까봐 간단하게 정리함.

`레이블이름:`으로 레이블을 정의, `goto 레이블이름`으로 이동 가능하다.

단, 가독성, 유지보수성, 구조적 프로그래밍 원칙 위반 등의 문제로 거의 사용하지 않는다.

```c
#include <stdio.h>

int main() {
    int i = 0;

loop:
    printf("%d\n", i);
    i++;

    if (i < 5)
        goto loop;

    return 0;
}
```

# 형변환(Casting)

`(타입이름) 변수 이름`을 사용해서 캐스팅 할 수 있다.

서로 다른 구조체/공용체(union) 사이의 형변환이나 상수 포인터의 형변환 등을 제외하고 대부분의 타입 간에서 형변환이 수행 가능하다.

- 암시적 형변환
	- 형변환(캐스팅) 기능을 사용하지 않는 것.
	- 컴파일 에러가 발생하지는 않지만, 의도하지 않는 값이 들어갈 수 있으므로 작은 크기의 데이터를 큰 데이터로 변환하는 경우 외에는 명시적으로 사용하는걸 권장한다.
	- 기존의 데이터가 손실될 수 있는 경우, IDE나 컴파일러가 경고를 해준다.
- 명시적 형변환
	- `(타입이름) 변수 이름`을 사용한 형변환
- 형변환 시 원본 데이터가 수정되지는 않는다.
	- 임시 변수를 사용하거나, 
	- 데이터를 다른 식으로 해석한다.
		- 4바이트 중 뒤 2바이트만 읽어서 `int`를 `short`로 바꾼다거나 하는 식

# 배열

사이즈가 고정된 정적 배열이다. 선언 시 정해줘야 함.

배열의 크기를 벗어나는 인덱스로 조회하더라도 컴파일 예외가 발생하지 않기 때문에 주의해야한다.

- `타입 배열이름[] = {값 목록1, 2}`
	- 깂 목록 개수만큼 크기가 정해진다.
	- 아니면 다음처럼 사용할 수도 있다.
		- `타입 배열이름[배열 크기] = {값 목록1, 2}`
		- 이러면 0~1번째는 초기화되고, 나머지는 더미 값이 들어간다.
- `타입 배열이름[배열 크기]`
	- 초기화 없이 선언만
- 배열 안에 배열을 집어넣어 N차원 배열을 만들 수 있다.
	- `타입 배열이름[1번째 배열 크기] ... [N번째 크기]`
	- 필요에 따라 초기화를 할 수 있는데,
		- `{{1,3}, {2,4}}` 처럼 중첩해서 사용하거나
		- `{1,3,2,4}` 처럼 힌 줄로 초기화 할 수도 있다. 
		- 어차피 컴파일러 입장에서는 연속된 메모리 공간에 저장되므로 동일하다.

```c
int myNumbers[] = {25, 50, 75, 100};

printf("%d", myNumbers[0]);
// output 25

// Declare an array of four integers:
int myNumbers[4];

// add element
myNumbers[0] = 25;
myNumbers[1] = 50;
myNumbers[2] = 75;
myNumbers[3] = 100;
```

#### C99이후 지원하는 가변 배열

배열 선언 시 크기를 런타임에 정하게 할 수 있다.

`scanf`로 입력받은 만큼의 크기를 선언할 수도 있음.

단, 어떤 위치에서 사용되는 Stack 영역에 정의되기 때문에 스택 오버플로우가 발생하지 않게, 크기를 잘 고려해야 한다.

- 배열의 메모리 위치
	- 정적/전역 배열: Data
	- 동적 배열(`malloc`같은거 사용 시): Heap
	- 지역(함수 내부)/동적 배열: Stack

# 포인터

개념 자체는 이해하고 있으므로 정리하지 않았다. (nand2tetris 하면서 저수준에서 많이 사용했다. Stack Pointer도 이름 자체가 포인터고, 주소값을 담고 있다. 아니면 Call Stack의 Frame의 Callee 주소도 그렇고)

아래 내용은 봤던 개발 블로그의 설명인데, 나는 이것보다 명확하게 설명할 방법이 생각나지 않는다.

> 메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수

다음과 같이 정의한다.
- `(포인터에 주소값이 저장되는 데이터의 형) *(포인터의 이름);`
- `(포인터에 주소값이 저장되는 데이터의 형)* (포인터의 이름);`


포인터는 주소값을 저장한다. 따라서 포인터의 크기는 데이터 타입에 관계없이 시스템 아키텍처에 따라 결정된다.      
32비트 시스템에선 4byte, 64비트 시스템에선 8byte이다. 

타입 정의가 필요한 이유: 포인터는 특정 데이터의 시작 주소값을 저장하고 있다. 이 시작 주소를 어디까지 읽어야 하는지는 타입(데이터의 크기)를 알아야 하기 때문이다.

#### `*`와 `&`
포인터를 사용하다보면 `*`와 `&`를 사용하는데, 둘 다 해당 기호룰 사용하는 연산자가 있다.     

연산을 위한 `*`와 `&`의 경우에는 두개의 피연산자가 필요하고, 포인터에서 주로 사용되는 `*`와 `&`는 하나의 피연산자(단항)만 필요하기 때문에 구분된다.

##### `*` 연산자
`*` 연산자는 포인터가 가리키는 메모리 주소에 저장된 값을 참조(역참조)하는데 사용된다.

선언 시에는 특정 변수가 포인터임을 나타낸다.

역참조 시에는 포인터가 가리키는 메모리 주소의 값을 가져온다. 이를 통해 함수의 인자로 전달되더라도 원본에 접근할 수 있다.

주소를 통해 간접적으로 접근하기 때문에 간접 연산자라고도 부른다.

##### `&` 연산자
다음과 같이 사용한다.
`&(주소값을 계산할 데이터)`

`&` 연산자는 변수의 메모리 주소를 반환한다.

#### 참조와 역참조

- **참조** (`&` 연산자): 변수의 메모리 주소를 가져오는 것.
    - 예: `int *p = &x;` (변수 `x`의 주소를 포인터 `p`에 저장)
- **역참조** (`*` 연산자): 포인터가 가리키는 주소의 값을 가져오는 것.
    - 예: `int y = *p;` (포인터 `p`가 가리키는 주소의 값을 변수 `y`에 저장)

#### 포인터와 상수(const)

위치에 따라 2가지의 의미를 가진다.

- `const int *p = &x`: 포인터가 가리키는 데이터가 상수
	- `x`는 변경 가능하지만, `*p`를 통해서 변경할 수 없음.
- `int const *p = &x`: 포인터 자체가 상수
	- `*p`는 변경 가능하지만, `p`는 변경 불가.
- `const int *const p = &x`: 포인터가 가리키는 데이터와 포인터가 상수

#### 포인터의 연산

다음 연산이 가능하다.

- 포인터 값에 덧셈과 뺄셈
	- 1을 더하더라도, 타입에 맞게 주소를 이동한다. (`int *`에 `++` 하면 4바이트를 더함)
- 포인터 간의 뺼셈: 두 포인터 간의 거리 계산. (덧셈은 불필요하므로 지원하지 않음.)
- 포인터 비교

#### 포인터와 배열

배열에 `sizeof`를 사용하면 할당된 영역 만큼의 크기를 반환한다.

하지만, 배열에서 배열의 이름은 배열의 첫 번째 원소의 주소값을 나타낸다. (`arr`의 값이 `arr[0]`의 주소와 같다.)

내부적으로 배열은 `[]` 연산자(몰랐는데, `[]`이 연산자라고 한다.)를 사용하여, `arr`(배열의 첫번째 시작 주소) + `offset` 연산을 통해 데이터를 가져온다.

포인터를 사용하여 배열의 데이터를 가져오는 것과 내부적으로는 동일하게 동작한다. 

따라서 `arr[3]`와 `*(arr + 3)`는 같다. (심지어 `3[arr]` 처럼 이상하게 사용할 수도 있다. 내부적으로는 `*(3 + arr)`으로 계산하기 때문)

다만 배열은 배열이고, 포인터는 포인터이기 때문에 배열 변수를 포인터처럼 다룰 수는 없다. (`arr++`은 컴파일 에러 발생)

```c
#include <stdio.h>  
  
int main() {  
    // 배열 선언 및 초기화  
    int arr[5] = {10, 20, 30, 40, 50};  
    int *ptr = arr; // 배열의 첫 번째 원소의 주소를 가리키는 포인터  
  
    // sizeof 연산자 사용  
    printf("배열의 크기 (바이트): %zu\n", sizeof(arr)); // 배열 전체의 크기  
    printf("배열의 원소 개수: %zu\n", sizeof(arr) / sizeof(arr[0])); // 원소 개수  
    printf("포인터의 크기 (바이트): %zu\n", sizeof(ptr)); // 포인터의 크기  
  
    // 배열의 이름과 첫 번째 원소의 주소 비교  
    printf("배열의 첫 번째 원소의 주소: %p\n", (void*)&arr[0]);  
    printf("배열의 이름 (첫 번째 원소의 주소): %p\n", (void*)arr);  
  
    // 배열의 데이터 접근 방법  
    printf("arr[3]: %d\n", arr[3]);  
    printf("*(arr + 3): %d\n", *(arr + 3));  
    printf("3[arr]: %d\n", 3[arr]); // 이상한 방식으로 배열 접근  
  
    // 포인터를 사용하여 배열의 데이터 접근  
    printf("ptr[3]: %d\n", ptr[3]);  
    printf("*(ptr + 3): %d\n", *(ptr + 3));  
  
    // 배열은 배열이고, 포인터는 포인터입니다. 배열 변수는 포인터처럼 다룰 수 없습니다.  
    // arr++; // 이 줄을 주석 해제하면 컴파일 에러가 발생합니다.  
  
    // 포인터는 포인터 연산을 사용할 수 있습니다.  
    ptr++;  
    printf("포인터가 가리키는 두 번째 원소: %d\n", *ptr);  
  
    return 0;  
}
```

#### 2중 포인터

```c
#include <stdio.h>  
  
int main() {  
    int a;  
    int *pa;  
    int **ppa;  
  
    pa = &a;  
    ppa = &pa;  
  
    a = 3;  
  
    printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);  
    printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);  
    printf("&pa : %p // ppa : %p \n", &pa, ppa);  
  
    return 0;  
}
```


#### 포인터 배열과 배열 포인터

둘은 다른 개념이다.

##### 포인터 배열 (Array of Pointers)

`int *arr[]`

포인터를 원소로 가지는 배열

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20, c = 30;
    int *arr[3] = {&a, &b, &c}; // 포인터 배열

    for (int i = 0; i < 3; i++) {
        printf("arr[%d]가 가리키는 값: %d\n", i, *arr[i]);
    }

    return 0;
}
```

##### 배열 포인터 (Pointer to Array)

`int (*ptr)[]`

괄호를 사용하지 않으면 포인터 배열로 인식하기 때문에 괄호를 꼭 사용해줘야 한다.

컴파일러가 배열의 각 요소에 접근하기 위해 필요한 메모리 오프셋을 계산할 수 있도록 `[]` 안에 내부 배열의 크기를 적어줘야 한다.

```c
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    int (*ptr)[4] = arr; // 배열의 첫 번째 행을 가리키는 포인터

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", ptr[i][j]); // arr[i][j]와 동일
        }
        printf("\n");
    }

	for (int i = 0; i < 3; i++) {  
	    for (int j = 0; j < 4; j++) {  
	        printf("%d ", ptr[0][j]); // arr[i][j]와 동일  
	    }  
	    ptr++;  
	    printf("\n");  
	}

    return 0;
}
```


#### 포인터 예제 코드

```c
#include <stdio.h>

int main() {
	int *p;
	int a;
	
	p = &a;
	*p = 3;
	
	printf("a 의 값 : %d \n", a);
	printf("*p 의 값 : %d \n", *p);
	
	return 0;
}
```

```c
#include <stdio.h>

int main() {  
    int x = 42;  
    int *p = &x;  // x의 주소를 p에 저장  
  
    printf("x의 주소: %p\n", &x);  // x의 주소 출력  
    printf("p의 값(즉, x의 주소): %p\n", p);  // p의 값 출력  
    printf("p가 가리키는 값: %d\n", *p);  // p가 가리키는 값(x의 값) 출력  
  
    *p = 100;  // p가 가리키는 주소의 값 변경 (즉, x의 값 변경)  
    printf("x의 새로운 값: %d\n", x);  // x의 값 출력  
  
    return 0;  
}
```

```c
#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;

    // 포인터가 가리키는 데이터가 상수인 경우
    const int *ptr1 = &x;
    // *ptr1 = 30; // 오류
    ptr1 = &y; // 가능

    // 포인터 자체가 상수인 경우
    int *const ptr2 = &x;
    *ptr2 = 30; // 가능
    // ptr2 = &y; // 오류

    // 포인터가 가리키는 데이터와 포인터 자체가 모두 상수인 경우
    const int *const ptr3 = &x;
    // *ptr3 = 40; // 오류
    // ptr3 = &y; // 오류

    return 0;
}
```

```c
#include <stdio.h>  
  
int main() {  
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
    int *parr;  
    int i;  
    parr = &arr[0];  
  
    for (i = 0; i < 10; i++) {  
        printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);  
        printf("(parr + %d) 의 값 : %p\n", i, (parr + i));  
    }  
    return 0;  
}
```


# 함수

# GPT
### [GPT 사용] C언어 함수 호출 과정 어셈블리어로 이해하기 

ARM64 어셈블리어 사용함. (mac m1을 사용하기 때문)

어차피 공통적인 흐름 정도를 알아보기 위한 거니까 ㄱㅊ

```c
#include <stdio.h>

int add(int a, int b);

int main(void) {
    int a = 2;
    int b = 12;

    printf("Result of add(a, b): %d\n", add(a, b));

    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

다음 코드를 CLion의 기능을 사용해 어셈블리어로 번역했다. (`-std=gnu11 -arch arm64 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.3.sdk`)
```arm
_main:
	sub	sp, sp, #48             // 스택 포인터를 48바이트 감소시켜 스택 프레임을 설정합니다.
	stp	x29, x30, [sp, #32]     // 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택에 저장합니다.
	add	x29, sp, #32            // 현재 스택 포인터에 32를 더해 프레임 포인터(x29)를 설정합니다.
	mov	w8, #0                  // w8 레지스터에 0을 저장합니다.
	str	w8, [sp, #16]           // w8(0)을 sp+16 위치에 저장합니다.
	stur	wzr, [x29, #-4]     // wzr(0)을 x29-4 위치에 저장합니다.
	mov	w8, #2                  // w8 레지스터에 2를 저장합니다.
	stur	w8, [x29, #-8]      // w8(2)을 x29-8 위치에 저장합니다. (a = 2)
	mov	w8, #12                 // w8 레지스터에 12를 저장합니다.
	stur	w8, [x29, #-12]     // w8(12)을 x29-12 위치에 저장합니다. (b = 12)
	ldur	w0, [x29, #-8]      // x29-8 위치에서 값을 로드하여 w0 레지스터에 저장합니다. (a 값 로드)
	ldur	w1, [x29, #-12]     // x29-12 위치에서 값을 로드하여 w1 레지스터에 저장합니다. (b 값 로드)
	bl	_add                    // add 함수를 호출합니다.
	mov	x9, sp                  // 스택 포인터 값을 x9 레지스터에 저장합니다.
	mov	x8, x0                  // x0 레지스터의 값을 x8 레지스터에 저장합니다.
	str	x8, [x9]                // x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
	adrp	x0, l_.str@PAGE     // 문자열 리터럴 l_.str의 페이지 주소를 x0 레지스터에 로드합니다.
	add	x0, x0, l_.str@PAGEOFF  // 문자열 리터럴 l_.str의 페이지 오프셋을 x0 레지스터에 더합니다.
	bl	_printf                 // printf 함수를 호출합니다.
	ldr	w0, [sp, #16]           // sp+16 위치에서 값을 로드하여 w0 레지스터에 저장합니다.
	ldp	x29, x30, [sp, #32]     // 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
	add	sp, sp, #48             // 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

_add:
	sub	sp, sp, #16             // 스택 포인터를 16바이트 감소시켜 스택 프레임을 설정합니다.
	str	w0, [sp, #12]           // w0 레지스터의 값을 sp+12 위치에 저장합니다.
	str	w1, [sp, #8]            // w1 레지스터의 값을 sp+8 위치에 저장합니다.
	ldr	w8, [sp, #12]           // sp+12 위치에서 값을 로드하여 w8 레지스터에 저장합니다.
	ldr	w9, [sp, #8]            // sp+8 위치에서 값을 로드하여 w9 레지스터에 저장합니다.
	add	w0, w8, w9              // w8과 w9의 값을 더하여 w0 레지스터에 저장합니다.
	add	sp, sp, #16             // 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

	.asciz	"Result of add(a, b): %d\n" // 문자열 리터럴
```

##### **중요한 부분 정리**

- main 함수에서부터 Call Stack을 사용하여 처리하는 모습을 볼 수 있다.    

- `add` 함수 호출 시
	- Stack Frame을 정의하고, `w0`, `w1`로 전달받은 매개변수를 Stack에 저장한다.
		- 미리 Stack Pointer를 증가시켜 사용할 Frame(매개변수, Callee 주소, 지역변수)을 공간을 선언한다.   
	- Stack에 저장된 변수를 가져와서 `w8`, `w9`에 저장하고 연산 결과를 `w0`에 저장한다.
	- 이후 SP를 낮춘 후 리턴한다.

- 파일 내 존재하지 않는 함수인 `printf`는 `bl`이라는 명령어로 호출한다.

###### 매개변수 전달 시 Stack에 저장하지 않은 이유
GTP 피셜로는 ARM의 경우 매개변수 4개까지는 함수 호출 시 레지스터를 사용한다고 한다. (반환 시에는 값이 하나이므로 마찬가지로 레지스터를 사용한다. x86의 경우에도 2개까지는 레지스터 (ECX, EDX)를 통해서 전달한다고 한다.)

4개를 넘어가면 스택을 사용한다고 한다.

#### GPT의 해설

##### 함수 호출 전후의 프레임 처리
1. **메인 함수 스택 프레임 설정**:
    - `sub sp, sp, #48`:
        - 스택 포인터를 48바이트 감소시켜 새로운 스택 프레임을 설정합니다. 이 공간은 지역 변수와 함수 호출의 저장 공간으로 사용됩니다.
    - `stp x29, x30, [sp, #32]`:
        - 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택의 sp+32 위치에 저장합니다. 이는 함수 호출이 끝난 후 원래의 호출 프레임으로 돌아가기 위해 필요합니다.
    - `add x29, sp, #32`:
        - 현재 스택 포인터 값에 32를 더하여 새로운 프레임 포인터(x29)를 설정합니다. 이제 x29는 현재 함수의 프레임 베이스 포인터가 됩니다.
2. **변수 초기화**:
    - `mov w8, #2` 및 `stur w8, [x29, #-8]`:
        - w8 레지스터에 2를 저장하고, 이를 x29-8 위치에 저장합니다. 이는 변수 `a`를 초기화하는 과정입니다.
    - `mov w8, #12` 및 `stur w8, [x29, #-12]`:
        - w8 레지스터에 12를 저장하고, 이를 x29-12 위치에 저장합니다. 이는 변수 `b`를 초기화하는 과정입니다.
3. **함수 호출 준비**:
    - `ldur w0, [x29, #-8]` 및 `ldur w1, [x29, #-12]`:
        - x29-8 위치의 값을 w0 레지스터에 로드하고, x29-12 위치의 값을 w1 레지스터에 로드합니다. 이는 함수 `add`의 인수 `a`와 `b`를 준비하는 과정입니다.
    - `bl _add`:
        - `add` 함수를 호출합니다. 이때 `w0`와 `w1` 레지스터의 값이 함수의 인수로 전달됩니다.

##### `add` 함수의 스택 프레임 설정 및 해제
4. **`add` 함수 스택 프레임 설정**:
    - `sub sp, sp, #16`:
        - 스택 포인터를 16바이트 감소시켜 새로운 스택 프레임을 설정합니다.
    - `str w0, [sp, #12]` 및 `str w1, [sp, #8]`:
        - `w0` 레지스터의 값을 sp+12 위치에 저장하고, `w1` 레지스터의 값을 sp+8 위치에 저장합니다. 이는 `add` 함수의 인수 `a`와 `b`를 스택에 저장하는 과정입니다.
5. **변수 값 로드 및 덧셈 연산**:
    - `ldr w8, [sp, #12]` 및 `ldr w9, [sp, #8]`:
        - sp+12 위치의 값을 w8 레지스터에 로드하고, sp+8 위치의 값을 w9 레지스터에 로드합니다.
    - `add w0, w8, w9`:
        - w8과 w9의 값을 더하여 w0 레지스터에 저장합니다. 이는 `a + b`의 결과를 계산하는 과정입니다.
6. **`add` 함수의 스택 프레임 해제 및 리턴**:
    - `add sp, sp, #16`:
        - 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다. 이때 결과 값은 `w0` 레지스터에 저장되어 있습니다.

##### `main` 함수의 나머지 처리
7. **printf 호출 준비 및 호출**:
    - `mov x9, sp` 및 `mov x8, x0`:
        - 스택 포인터 값을 x9 레지스터에 저장하고, `add` 함수의 결과 값을 x8 레지스터에 저장합니다.
    - `str x8, [x9]`:
        - x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
    - `adrp x0, l_.str@PAGE` 및 `add x0, x0, l_.str@PAGEOFF`:
        - 문자열 리터럴 l_.str의 페이지 주소와 페이지 오프셋을 x0 레지스터에 로드합니다.
    - `bl _printf`:
        - `printf` 함수를 호출합니다.
8. **메인 함수 스택 프레임 해제 및 리턴**:
    - `ldr w0, [sp, #16]`:
        - sp+16 위치의 값을 w0 레지스터에 로드합니다. (사용되지 않는 코드로 보임)
    - `ldp x29, x30, [sp, #32]`:
        - 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
    - `add sp, sp, #48`:
        - 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다.
