
확실히 저수준에 대한 이해가 있는 상태에서 다시 배우니까 이해가 잘 되고 재밌다. 점프 테이블이 이제 이해된다거나, 형변환 시 원본 데이터에 대한 궁금증이 생긴다거나...

# 유용한 사이트

정리할때도 참고함

- [씹어먹는 C 언어 시리즈](https://modoocode.com/231): C 언어 배울 때, 주로 참고한 사이트
- [C CheatSheet](https://quickref.me/c.html): 문법을 어느정도 안다는 가정 하에 빠르게 찾아보기 좋음.
- [마이크로소프트 C 참고 문서](https://learn.microsoft.com/ko-kr/cpp/c-language/organization-of-the-c-language-reference?view=msvc-170): 정확한 C언어 문법 참고를 웹으로 하고 싶을때 사용, 단 C89 기준이고, Microsoft의 확장 기능이 서술되어 있음을 주의.
- [나무위키 C언어 문법](<https://namu.wiki/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)/%EB%AC%B8%EB%B2%95>): 한글로 된 확인하기 쉬운 C문법
- [Reading C](http://unixwiz.net/techtips/reading-cdecl.html): C언어 복잡한 데이터 읽는 법

# 변수, 타입, printf

```c
#include <stdio.h>  
  
// 구글 C++ 스타일 가이드 번역 (C 가이트는 잘 없더라)  
// https://jongwook.kim/google-styleguide/trunk/cppguide.xml#%EC%A3%BC%EC%84%9D  
  
int add(int a, int b); // 함수 프로토타입, 컴파일러에게 함수의 존재를 알림  
  
/*  
 * 긴 주석, 아마 함수의 명세에 대한 설명을 작성할 때 주로 사용할 듯?  
 * // 는 코드 중간에서 일부 문맥 설명할 때나 쓰고...  
 */int main(void) { // void는 함수의 파라미터/리턴 타입이 없음을 지정, 혹은 모든 타입을 받는 포인터 타입 지정 시 사용  
    // 변수 선언 및 초기화  
    int integer_var = 42;           // 정수형 변수  
    unsigned int uint_var = 42;     // unsigned(부호 없는) 정수형 변수  
    float float_var = 3.14f;        // float, f를 붙여 4byte 리터럴 값임을 명시  
    double double_var = 3.141592;   // double  
    char char_var = 'A';            // 문자형 변수, ' 사용  
    char str_var[] = "Hello, C!";   // 문자열 변수, " 사용  
    int *ptr_var = &integer_var;  
  
  
    // 변수 출력  
    printf("Integer: %d\n", integer_var);   // 정수형 변수 출력 (%d)    printf("Integer: %d\n", uint_var);      // unsigned 정수형 변수 출력 (%d)    printf("Float: %f\n", float_var);       // float (%f)  
    printf("Double: %lf\n", double_var);    // double (%lf)  
    printf("Character: %c\n", char_var);    // 문자형 변수 출력 (%c)    printf("String: %s\n", str_var);        // 문자열 변수 출력 (%s)    printf("Address: %p\n", ptr_var);       // 포인터가 참조하는 주소 (%p)  
    // 함수 호출  
    int result = add(5, 3);                // 함수 호출: add 함수에 5와 3을 인수로 전달  
    printf("Result of add(5, 3): %d\n", result); // 함수 결과 출력  
  
    return 0; // 프로그램 종료 상태를 반환 0은 성공, 1은 실패  
}  
  
// 함수 정의  
int add(int a, int b) {  
    return a + b;  
}
```

#### 상수

변수 선언문 앞에 `const`를 추가하여 상수로 만들 수 있다.

상수는 선언과 함께 초기화가 필수이며, 수정할 수 없다. (수정 시 컴파일러 에러 발생)

#### 변수의 선언과 초기화

변수 선언 이후, 초기화를 하지 않으면 쓰레기 값이 남아있는 상태이다.

초기화를 통해 값을 지정해주어야 한다.

이 경우 컴파일러가 경고를 띄울 수 있다.

#### Bool 타입

C99 부터 [bool 타입을 지원](https://medium.com/@kyle_seongwoo_jun/c%EC%97%90%EC%84%9C-bool-%ED%83%80%EC%9E%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-105ecaf1db02)한다.

`_Bool`이라는 이름이 있는데, 일반적인 타입 이름과 달라서 `#include <stdbool.h>`를 사용해서 `bool`이라는 이름으로 사용할수도 있다.

그 전에는 0을 거짓, 나머지 값은 참으로 간주했다.

#### Void 타입

`void`는 값을 담는 변수로는 기능할 수 없다. 의미 상 불가능하기 때문. 빈(공허한) 데이터를 저장하는 변수라는게 말이 안됨.

`void`는 함수의 매게변수나 리턴 타입이 없음을 명시할 때 쓰거나, 모든 타입의 포인터를 받을 때 사용한다.

포인터로서 사용하는 경우, 실제로 데이터에 접근하기 위해서는 적절한 offset을 알아야하기 때문에, 형변환을 수행해야만 한다. 



# 산술, 비트, 대입 연산자

(GPT의 도움을 받음)

우선순위와 같은 부분이 중요하긴 한데, 애매한 부분은 그냥 괄호를 사용하는 식으로 할 예정. 어차피 의미없는 괄호라면 IDE가 경고해주기 때문에... (그리고 그런 애매한 부분은 괄호 써서 확실하게 하는게 좋다고 생각함)

비트 연산이 조금 생소하긴 한데, 이해 못하는 정도는 아니고, java에서도 쓰긴 하니까 따로 정리는 안함.

- **산술 연산자**:
    - 덧셈 (`+`)
    - 뺄셈 (`-`)
    - 곱셈 (`*`)
    - 나눗셈 (`/`)
    - 나머지 (`%`)
    - 증감 연산자 (`++`, `--`)
- **비트 연산자**:
    - AND (`&`)
    - OR (`|`)
    - XOR (`^`)
    - NOT (`~`)
    - 왼쪽 시프트 (`<<`)
    - 오른쪽 시프트 (`>>`)
- **대입 연산자**:
    - 대입 (`=`)
    - 더하기 후 대입 (`+=`)
    - 빼기 후 대입 (`-=`)
    - 곱하기 후 대입 (`*=`)
    - 나누기 후 대입 (`/=`)
    - 나머지 후 대입 (`%=`)
    - AND 후 대입 (`&=`)
    - OR 후 대입 (`|=`)
    - XOR 후 대입 (`^=`)
    - 왼쪽 시프트 후 대입 (`<<=`)
    - 오른쪽 시프트 후 대입 (`>>=`)

```c
#include <stdio.h>

int main() {
    // 산술 연산자
    int a = 10;
    int b = 5;
    int result;

    // 덧셈
    result = a + b;  // result = 15
    printf("a + b = %d\n", result);

    // 뺄셈
    result = a - b;  // result = 5
    printf("a - b = %d\n", result);

    // 곱셈
    result = a * b;  // result = 50
    printf("a * b = %d\n", result);

    // 나눗셈
    result = a / b;  // result = 2
    printf("a / b = %d\n", result);

    // 나머지 연산
    result = a % b;  // result = 0
    printf("a %% b = %d\n", result);

    // 증감 연산자
    a++;  // a = 11
    printf("a++ = %d\n", a);

    b--;  // b = 4
    printf("b-- = %d\n", b);

    // 비트 연산자
    int x = 6;  // 6 = 00000110 in binary
    int y = 3;  // 3 = 00000011 in binary

    // AND
    result = x & y;  // result = 2 (00000010 in binary)
    printf("x & y = %d\n", result);

    // OR
    result = x | y;  // result = 7 (00000111 in binary)
    printf("x | y = %d\n", result);

    // XOR
    result = x ^ y;  // result = 5 (00000101 in binary)
    printf("x ^ y = %d\n", result);

    // NOT
    result = ~x;  // result = -7 (11111001 in binary, two's complement)
    printf("~x = %d\n", result);

    // 왼쪽 시프트
    result = x << 1;  // result = 12 (00001100 in binary)
    printf("x << 1 = %d\n", result);

    // 오른쪽 시프트
    result = x >> 1;  // result = 3 (00000011 in binary)
    printf("x >> 1 = %d\n", result);

    // 대입 연산자
    int z = 0;

    // 더하기 후 대입
    z += a;  // z = z + a (z = 0 + 11, z = 11)
    printf("z += a = %d\n", z);

    // 빼기 후 대입
    z -= b;  // z = z - b (z = 11 - 4, z = 7)
    printf("z -= b = %d\n", z);

    // 곱하기 후 대입
    z *= a;  // z = z * a (z = 7 * 11, z = 77)
    printf("z *= a = %d\n", z);

    // 나누기 후 대입
    z /= b;  // z = z / b (z = 77 / 4, z = 19)
    printf("z /= b = %d\n", z);

    // 나머지 후 대입
    z %= a;  // z = z % a (z = 19 % 11, z = 8)
    printf("z %%= a = %d\n", z);

    // AND 후 대입
    z &= x;  // z = z & x (z = 8 & 6, z = 0)
    printf("z &= x = %d\n", z);

    // OR 후 대입
    z |= y;  // z = z | y (z = 0 | 3, z = 3)
    printf("z |= y = %d\n", z);

    // XOR 후 대입
    z ^= x;  // z = z ^ x (z = 3 ^ 6, z = 5)
    printf("z ^= x = %d\n", z);

    // 왼쪽 시프트 후 대입
    z <<= 2;  // z = z << 2 (z = 5 << 2, z = 20)
    printf("z <<= 2 = %d\n", z);

    // 오른쪽 시프트 후 대입
    z >>= 1;  // z = z >> 1 (z = 20 >> 1, z = 10)
    printf("z >>= 1 = %d\n", z);

    return 0;
}
```


# if, for, while, switch, goto

자바랑 크게 다르지 않고, 간단한 사용법은 [C CheatSheet](https://quickref.me/c.html)가 잘 되어있어서 생략.

공부하면서 필요하다고 생각한 부분만 메모

- 논리 연산자
	- AND: `&&`
	- OR: `||`
	- **`&` 대신 `&&`를 쓰는 이유**
		- `&`는 확실하게 비트 `AND` 연산 외의 경우에는 (유효하더라도) 사용하지 않는게 좋다.
		- Short Circuit Evaluation 떄문인데, 더 이상 논리를 확인하지 않고 결과를 알 수 있는 경우 생략한다. `&`는 이 SCE를 지원하지 못한다. (정확한 계산 결과가 필요하기 때문)
- **`switch` 문이 필요한 이유**
	- `if-else`보다 성능이 더 좋은 경우가 있다.
	- `if-else`의 경우 매 블록마다 비교 연산(CMP)이 발생한다. 최악의 경우, 모든 조건을 평가한다.
	- `switch`문은 `jump table`을 사용해서 효율적으로 처리한다. 주어진 값에 따라 해당 로직을 처리하는 주소로 `jump`하기 때문에 case가 아무리 많아져도 효율적으로 처리된다. (한 번의 검사)
	- 이게 가능한 이유는 switch문의 변수 타입이 제한되어 있기 때문이다.
		- 반대로 `if-else`문에 작성하는 조건은 자유롭게 작성할 수 있다.
	- `switch`문이 효율적으로 처리되기 위한 조건
		- 어셈블리어를 설명해야 해서 대충 결론만 설명. 아래 경우가 해당이 안되면 다른 방식으로 최적화 하거나 `if-else` 처럼 처리하기도 함.
		1. 케이스가 상수 값이어야 함: 변수가 들어가면 `jump table`로 최적화가 불가능
		2. 케이스 값이 연속적이거나 범위가 좁아야  함: 값 간의 차이가 크면 `jump table`로 최적화가 비효율적임
	- `if-else`와 `switch` 사용에 대한 개인적인 생각
		- 최적화, 가독성을 위한 제한적인 경우 말고는 `if-else`가 더 좋다고 생각함.
		- `switch`는 들어오는 변수 타입을 제한해 버려서 확장이 어렵기 때문임.
			- `int`나 문자열처럼 제한적인게 확실한 경우면 모를까.
			- 코드를 개발하다보면 여러 조건을 처리하게 되는데, 이런 조건을 작성하는데 제한이 생기는게 좋지 않다고 생각함.
			- 물론 여러 조건을 작성해야 하는 경우 자체가 코드 품질을 떨어트리거나, 설계의 오류가 될 수도 있다고 생각하는데
				- 실무에서는 그런 돌발 상황을 처리해야 할 때가 있을꺼라 생각함.

###### goto문 사용법

goto문을 정리할 필요가 있나 싶긴 한데, 그래도 나중에 궁금해질까봐 간단하게 정리함.

`레이블이름:`으로 레이블을 정의, `goto 레이블이름`으로 이동 가능하다.

단, 가독성, 유지보수성, 구조적 프로그래밍 원칙 위반 등의 문제로 거의 사용하지 않는다.

```c
#include <stdio.h>

int main() {
    int i = 0;

loop:
    printf("%d\n", i);
    i++;

    if (i < 5)
        goto loop;

    return 0;
}
```

# 형변환(Casting)

`(타입이름) 변수 이름`을 사용해서 캐스팅 할 수 있다.

서로 다른 구조체/공용체(union) 사이의 형변환이나 상수 포인터의 형변환 등을 제외하고 대부분의 타입 간에서 형변환이 수행 가능하다.

- 암시적 형변환
	- 형변환(캐스팅) 기능을 사용하지 않는 것.
	- 컴파일 에러가 발생하지는 않지만, 의도하지 않는 값이 들어갈 수 있으므로 작은 크기의 데이터를 큰 데이터로 변환하는 경우 외에는 명시적으로 사용하는걸 권장한다.
	- 기존의 데이터가 손실될 수 있는 경우, IDE나 컴파일러가 경고를 해준다.
- 명시적 형변환
	- `(타입이름) 변수 이름`을 사용한 형변환
- 형변환 시 원본 데이터가 수정되지는 않는다.
	- 임시 변수를 사용하거나, 
	- 데이터를 다른 식으로 해석한다.
		- 4바이트 중 뒤 2바이트만 읽어서 `int`를 `short`로 바꾼다거나 하는 식

# 배열

사이즈가 고정된 정적 배열이다. 선언 시 정해줘야 함.

배열의 크기를 벗어나는 인덱스로 조회하더라도 컴파일 예외가 발생하지 않기 때문에 주의해야한다.

- `타입 배열이름[] = {값 목록1, 2}`
	- 깂 목록 개수만큼 크기가 정해진다.
	- 아니면 다음처럼 사용할 수도 있다.
		- `타입 배열이름[배열 크기] = {값 목록1, 2}`
		- 이러면 0~1번째는 초기화되고, 나머지는 더미 값이 들어간다.
- `타입 배열이름[배열 크기]`
	- 초기화 없이 선언만
- 배열 안에 배열을 집어넣어 N차원 배열을 만들 수 있다.
	- `타입 배열이름[1번째 배열 크기] ... [N번째 크기]`
	- 필요에 따라 초기화를 할 수 있는데,
		- `{{1,3}, {2,4}}` 처럼 중첩해서 사용하거나
		- `{1,3,2,4}` 처럼 힌 줄로 초기화 할 수도 있다. 
		- 어차피 컴파일러 입장에서는 연속된 메모리 공간에 저장되므로 동일하다.

```c
int myNumbers[] = {25, 50, 75, 100};

printf("%d", myNumbers[0]);
// output 25

// Declare an array of four integers:
int myNumbers[4];

// add element
myNumbers[0] = 25;
myNumbers[1] = 50;
myNumbers[2] = 75;
myNumbers[3] = 100;
```

#### C99이후 지원하는 가변 배열

배열 선언 시 크기를 런타임에 정하게 할 수 있다.

`scanf`로 입력받은 만큼의 크기를 선언할 수도 있음.

단, 어떤 위치에서 사용되는 Stack 영역에 정의되기 때문에 스택 오버플로우가 발생하지 않게, 크기를 잘 고려해야 한다.

- 배열의 메모리 위치
	- 정적/전역 배열: Data
	- 동적 배열(`malloc`같은거 사용 시): Heap
	- 지역(함수 내부)/동적 배열: Stack

# 포인터

개념 자체는 이해하고 있으므로 정리하지 않았다. (nand2tetris 하면서 저수준에서 많이 사용했다. Stack Pointer도 이름 자체가 포인터고, 주소값을 담고 있다. 아니면 Call Stack의 Frame의 Callee 주소도 그렇고)

아래 내용은 봤던 개발 블로그의 설명인데, 나는 이것보다 명확하게 설명할 방법이 생각나지 않는다.

> 메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수

다음과 같이 정의한다.
- `(포인터에 주소값이 저장되는 데이터의 형) *(포인터의 이름);`
- `(포인터에 주소값이 저장되는 데이터의 형)* (포인터의 이름);`


포인터는 주소값을 저장한다. 따라서 포인터의 크기는 데이터 타입에 관계없이 시스템 아키텍처에 따라 결정된다.      
32비트 시스템에선 4byte, 64비트 시스템에선 8byte이다. 

타입 정의가 필요한 이유: 포인터는 특정 데이터의 시작 주소값을 저장하고 있다. 이 시작 주소를 어디까지 읽어야 하는지는 타입(데이터의 크기)를 알아야 하기 때문이다.

#### `*`와 `&`
포인터를 사용하다보면 `*`와 `&`를 사용하는데, 둘 다 해당 기호룰 사용하는 연산자가 있다.     

연산을 위한 `*`와 `&`의 경우에는 두개의 피연산자가 필요하고, 포인터에서 주로 사용되는 `*`와 `&`는 하나의 피연산자(단항)만 필요하기 때문에 구분된다.

##### `*` 연산자
`*` 연산자는 포인터가 가리키는 메모리 주소에 저장된 값을 참조(역참조)하는데 사용된다.

선언 시에는 특정 변수가 포인터임을 나타낸다.

역참조 시에는 포인터가 가리키는 메모리 주소의 값을 가져온다. 이를 통해 함수의 인자로 전달되더라도 원본에 접근할 수 있다.

주소를 통해 간접적으로 접근하기 때문에 간접 연산자라고도 부른다.

##### `&` 연산자
다음과 같이 사용한다.
`&(주소값을 계산할 데이터)`

`&` 연산자는 변수의 메모리 주소를 반환한다.

#### 참조와 역참조

- **참조** (`&` 연산자): 변수의 메모리 주소를 가져오는 것.
    - 예: `int *p = &x;` (변수 `x`의 주소를 포인터 `p`에 저장)
- **역참조** (`*` 연산자): 포인터가 가리키는 주소의 값을 가져오는 것.
    - 예: `int y = *p;` (포인터 `p`가 가리키는 주소의 값을 변수 `y`에 저장)

#### 포인터와 상수(const)

위치에 따라 2가지의 의미를 가진다.

- `const int *p = &x`: 포인터가 가리키는 데이터가 상수
	- `x`는 변경 가능하지만, `*p`를 통해서 변경할 수 없음.
- `int const *p = &x`: 포인터 자체가 상수
	- `*p`는 변경 가능하지만, `p`는 변경 불가.
- `const int *const p = &x`: 포인터가 가리키는 데이터와 포인터가 상수

#### 포인터의 연산

다음 연산이 가능하다.

- 포인터 값에 덧셈과 뺄셈
	- 1을 더하더라도, 타입에 맞게 주소를 이동한다. (`int *`에 `++` 하면 4바이트를 더함)
- 포인터 간의 뺼셈: 두 포인터 간의 거리 계산. (덧셈은 불필요하므로 지원하지 않음.)
- 포인터 비교

#### 포인터와 배열

배열에 `sizeof`를 사용하면 할당된 영역 만큼의 크기를 반환한다.

하지만, 배열에서 배열의 이름은 배열의 첫 번째 원소의 주소값을 나타낸다. (`arr`의 값이 `arr[0]`의 주소와 같다. 따라서 다음과 같이 사용 가능 `int *ptr = arr`, `ptr`은 첫 번째 요소를 바라보는 포인터이다.)

내부적으로 배열은 `[]` 연산자(몰랐는데, `[]`이 연산자라고 한다.)를 사용하여, `arr`(배열의 첫번째 시작 주소) + `offset` 연산을 통해 데이터를 가져온다.

포인터를 사용하여 배열의 데이터를 가져오는 것과 내부적으로는 동일하게 동작한다. 

따라서 `arr[3]`와 `*(arr + 3)`는 같다. (심지어 `3[arr]` 처럼 이상하게 사용할 수도 있다. 내부적으로는 `*(3 + arr)`으로 계산하기 때문)

다만 배열은 배열이고, 포인터는 포인터이기 때문에 배열 변수를 포인터처럼 다룰 수는 없다. (`arr++`은 컴파일 에러 발생)

```c
#include <stdio.h>  
  
int main() {  
    // 배열 선언 및 초기화  
    int arr[5] = {10, 20, 30, 40, 50};  
    int *ptr = arr; // 배열의 첫 번째 원소의 주소를 가리키는 포인터  
  
    // sizeof 연산자 사용  
    printf("배열의 크기 (바이트): %zu\n", sizeof(arr)); // 배열 전체의 크기  
    printf("배열의 원소 개수: %zu\n", sizeof(arr) / sizeof(arr[0])); // 원소 개수  
    printf("포인터의 크기 (바이트): %zu\n", sizeof(ptr)); // 포인터의 크기  
  
    // 배열의 이름과 첫 번째 원소의 주소 비교  
    printf("배열의 첫 번째 원소의 주소: %p\n", (void*)&arr[0]);  
    printf("배열의 이름 (첫 번째 원소의 주소): %p\n", (void*)arr);  
  
    // 배열의 데이터 접근 방법  
    printf("arr[3]: %d\n", arr[3]);  
    printf("*(arr + 3): %d\n", *(arr + 3));  
    printf("3[arr]: %d\n", 3[arr]); // 이상한 방식으로 배열 접근  
  
    // 포인터를 사용하여 배열의 데이터 접근  
    printf("ptr[3]: %d\n", ptr[3]);  
    printf("*(ptr + 3): %d\n", *(ptr + 3));  
  
    // 배열은 배열이고, 포인터는 포인터입니다. 배열 변수는 포인터처럼 다룰 수 없습니다.  
    // arr++; // 이 줄을 주석 해제하면 컴파일 에러가 발생합니다.  
  
    // 포인터는 포인터 연산을 사용할 수 있습니다.  
    ptr++;  
    printf("포인터가 가리키는 두 번째 원소: %d\n", *ptr);  
  
    return 0;  
}
```

#### 2중 포인터

```c
#include <stdio.h>  
  
int main() {  
    int a;  
    int *pa;  
    int **ppa;  
  
    pa = &a;  
    ppa = &pa;  
  
    a = 3;  
  
    printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);  
    printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);  
    printf("&pa : %p // ppa : %p \n", &pa, ppa);  
  
    return 0;  
}
```


#### 포인터 배열과 배열 포인터

둘은 다른 개념이다.

##### 포인터 배열 (Array of Pointers)

`int *arr[]`

포인터를 원소로 가지는 배열

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20, c = 30;
    int *arr[3] = {&a, &b, &c}; // 포인터 배열

    for (int i = 0; i < 3; i++) {
        printf("arr[%d]가 가리키는 값: %d\n", i, *arr[i]);
    }

    return 0;
}
```

##### 배열 포인터 (Pointer to Array)

`int (*ptr)[]`

괄호를 사용하지 않으면 포인터 배열로 인식하기 때문에 괄호를 꼭 사용해줘야 한다.

컴파일러가 배열의 각 요소에 접근하기 위해 필요한 메모리 오프셋을 계산할 수 있도록 `[]` 안에 내부 배열의 크기를 적어줘야 한다.

```c
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    int (*ptr)[4] = arr; // 배열의 첫 번째 행을 가리키는 포인터

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", ptr[i][j]); // arr[i][j]와 동일
        }
        printf("\n");
    }

	for (int i = 0; i < 3; i++) {  
	    for (int j = 0; j < 4; j++) {  
	        printf("%d ", ptr[0][j]); // arr[i][j]와 동일  
	    }  
	    ptr++;  
	    printf("\n");  
	}

    return 0;
}
```


#### 포인터 예제 코드

```c
#include <stdio.h>

int main() {
	int *p;
	int a;
	
	p = &a;
	*p = 3;
	
	printf("a 의 값 : %d \n", a);
	printf("*p 의 값 : %d \n", *p);
	
	return 0;
}
```

```c
#include <stdio.h>

int main() {  
    int x = 42;  
    int *p = &x;  // x의 주소를 p에 저장  
  
    printf("x의 주소: %p\n", &x);  // x의 주소 출력  
    printf("p의 값(즉, x의 주소): %p\n", p);  // p의 값 출력  
    printf("p가 가리키는 값: %d\n", *p);  // p가 가리키는 값(x의 값) 출력  
  
    *p = 100;  // p가 가리키는 주소의 값 변경 (즉, x의 값 변경)  
    printf("x의 새로운 값: %d\n", x);  // x의 값 출력  
  
    return 0;  
}
```

```c
#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;

    // 포인터가 가리키는 데이터가 상수인 경우
    const int *ptr1 = &x;
    // *ptr1 = 30; // 오류
    ptr1 = &y; // 가능

    // 포인터 자체가 상수인 경우
    int *const ptr2 = &x;
    *ptr2 = 30; // 가능
    // ptr2 = &y; // 오류

    // 포인터가 가리키는 데이터와 포인터 자체가 모두 상수인 경우
    const int *const ptr3 = &x;
    // *ptr3 = 40; // 오류
    // ptr3 = &y; // 오류

    return 0;
}
```

```c
#include <stdio.h>  
  
int main() {  
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
    int *parr;  
    int i;  
    parr = &arr[0];  
  
    for (i = 0; i < 10; i++) {  
        printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);  
        printf("(parr + %d) 의 값 : %p\n", i, (parr + i));  
    }  
    return 0;  
}
```

# 함수

개념은 생략.

`int main()` 또한 함수이다. Call Stack에 올라간다.

함수는 미리 정의되어야 사용할 수 있다. 일반적으로 `main`이 맨 위에 온다.    
그래서 원형(`prototype`)을 사용해서 함수의 정의 전에 작성되어 컴파일러가 함수 호출을 이해할 수 있도록 한다.

상수(`const`)를 사용해서 `int func(const int val);` 처럼 인자 값을 불변으로 정의할 수 있다.

##### Call By Value/Reference

- **Call By Value**: 함수에 값의 복사본을 전달. 원본 값에는 영향 없음. 일반적인 타입 (구조체 포함)
- **Call By Reference**: 함수에 변수의 주소를 전달. 원본 값이 변경됨. 포인터를 사용함.

```c
#include <stdio.h>  
  
int swap(int *a, int *b) {  
    int temp = *a;  
  
    *a = *b;  
    *b = temp;  
  
    return 0;  
}  
  
int main() {  
    int i, j;  
  
    i = 3;  
    j = 5;  
  
    printf("SWAP 이전 : i : %d, j : %d \n", i, j);  
  
    swap(&i, &j);  
  
    printf("SWAP 이후 : i : %d, j : %d \n", i, j);  
  
    return 0;  
}
```

##### 함수 포인터

쓸 일이 뭐 있나 싶긴 한데, 함수 역시 주소 값을 가지고 있으므로 함수 포인터를 사용할 수도 있다.

```c
#include <stdio.h>  
  
int max(int a, int b);  
  
int main() {  
    int a = 1;  
    int b = 2;  
    int (*pmax)(int, int) = max;  
  
    printf("max(a,b) : %d \n", max(a, b));  
    printf("pmax(a,b) : %d \n", pmax(a, b));  
  
    return 0;  
}  
  
int max(int a, int b) {  
    if (a > b)  
        return a;  
    else  
        return b;  
}
```


##### main 함수의 인자
다음과 같이 인자를 가지도록 선언할 수도 있다. `int main(int argc, char **argv)`

- **`argc` (argument count)**: 프로그램이 실행될 때 전달되는 인자의 개수
- **`argv` (argument vector)**: 프로그램에 전달된 인자들을 가리키는 문자열 배열. `argv`는 `char **` 타입으로, 문자열 배열을 가리키는 포인터이다. 따라서 `argv[i]`와 같이 인덱스로 접근할 수 있으며, 각 요소는 `char *` 타입의 문자열을 가리킨다. (`char *`는 `char[]` 와 차이가 있기는 하지만, 비슷함. `char *`는 수정 불가능한 문자열 리터럴의 시작 주소를 가리킴)

```c
#include <stdio.h>

int main(int argc, char **argv) {
  int i;
  printf("받은 인자의 개수 : %d \n", argc);

  for (i = 0; i < argc; i++) {
    printf("이 프로그램이 받은 인자 : %s \n", argv[i]);
  }

  return 0;
}
```

# 문자열

##### NULL

문자열의 가장 마지막에는 자동으로 `\0`(NULL) 문자가 들어간다. (문자열을 사용할 때마다 매번 길이를 구하지 않을 수 있기 때문에 이렇게 만들어졌다고 함.)

`NULL`는 null pointer constant(널 포인터 상수)로, 컴파일러에 의해 `(void*)0`로 정의된다.

다만 문자열의 경우 0을 표시하기 위해 `\0`라는 문자를 null로 사용한다.

null 문자는 아스키 값이 0이다. (실제 0은 아스키코드 48이다.)

##### stdin

`stdin`은 입력 스트림 혹은 입력 버퍼로, `scanf()`를 사용하는 경우 해당 버퍼의 값을 읽는다.

`scanf("%c", &c);`처럼 char를 받는건 권장하지 않다.    
경우에 따라 버퍼에 `\n`(개행문자)가 남아있을 수 있는데, char는 한 개의 문자만을 읽기 떄문에, 남아있는 개행문자를 가져와버린다.

따라서 문자를 하나 받더라도 문자열 `%s`로 입력받고 처리하는게 좋다.

> 결론적으로 요약하자면 `%s` 나 `%d` 그리고 다른 모든 수 데이터를 입력 받는 형식은 버퍼에 남아 있는 공백 문자에 신경쓰지 않고 사용할 수 있습니다.
> 
> 그렇다고 해서 %s 를 입력 받는 후 버퍼가 완벽히 깨끗해 지는 것이 아닙니다. 개행 문자는 뒤에 남아있죠!
> 
> 하지만 `%c` 를 이용할 때 에는 버퍼에 무엇이 남아 있는지 잘 고려해야 합니다.

##### 리터럴

문자열 리터럴은 다음과 같이 정의하고 사용한다.

`char *str1 = "Hello";`

> 프로그래밍 언어에서 리터럴(literal)이란, 소스 코드 상에서 고정된 값을 가지는 것을 일컫습니다. 특히, C 언어의 경우 큰 따옴표(`"`) 로 묶인 것들을 문자열 리터럴(string literal) 이라 부릅니다.

문자열을 입력받는 경우가 아니라, 코드에서 명시하는 경우 리터럴 값으로 처리된다.

텍스트 세그먼트(text segment) 에 프로그램 코드와 상수, 리터럴 등이 위치하는데, 해당 영역은 읽기 작업만 수행할 수 있다. 

따라서 리터럴 값을 새로 정의하는게 아니라 `str_val[0] = 'a'` 와 같이 수정하는 경우 에러가 발생한다.

다만 `char str2[] = "Hello";`와 같이 배열로 정의하는 경우, 리터럴 값을 복사해서 배열(stack 영역에 생성됨)에 저장하기 때문에 문제 없이 수정할 수 있다. (정적, 전역 배열의 경우, data에 정의된다. 이 영역 또한 읽기와 수정이 가능하다.)

###### 예시
문자열 합치기
```c
#include <stdio.h>  
  
int stradd(char *dest, char *src);  
  
int main() {  
    char str1[100] = "hello my name is ";  
    char str2[] = "Psi";  
  
    printf("합치기 이전 : %s \n", str1);  
  
    stradd(str1, str2);  
  
    printf("합친 이후 : %s \n", str1);  
  
    return 0;  
}  
  
int stradd(char *dest, char *src) {  
    /* dest 의 끝 부분을 찾는다.*/  
    while (*dest) {  
        dest++;  
    }  
  
    /*  
    while 문을 지나고 나면 dest 는 dest 문자열의 NULL 문자를 가리키고 있게 된다.  
    이제 src 의 문자열들을 dest 의 NULL 문자 있는 곳 부터 복사해넣는다.  
    */    
    while (*src) {  
        *dest = *src;  
        src++;  
        dest++;  
    }  
  
    /* 마지막으로 dest 에 NULL 추가 (왜냐하면 src 에서 NULL 이 추가 되지  
     * 않았으므로) */  
    *dest = '\0';  
  
    return 1;  
}
```

# 구조체(struct)

다음과 같이 정의한다.
```c
struct 구조체이름 {
	타입 변수이름; // 구조체 정의 시 초기화를 할 수 없다.
};

// 코드에서는 다음과 같이 접근한다.
int main() {
	struct 구조체이름 구조체변수이름 = {초기 값1, 2 ... }

	struct 구조체이름 구조체변수이름;

	구조체변수이름.멤버변수A = 'A'
	printf(구조체변수이름.멤버변수B)
}
```

##### 구조체 포인터

`struct 구조체이름 *포인터이름 = &기존구조체;` 처럼 일반적인 타입들처럼 사용할 수 있다. (크기 역시 일반적인 포인터와 동일하다. 그냥 구조체에 사용하는 포인터일 뿐, 별 차이 없다.)

다만 포인터의 멤버에 접근하는 경우 `->`를 사용하는 것이 좋다.

일반적인 포인터를 사용하는 경우 `(*ptr).a`와 같이 `(특정 구조체 포인터 역참조).멤버`임을 알려야 하기 때문이다.    
그렇지 않으면 `*(ptr.a)`로 인식해 버린다.   
이런 불편함을 해결하기 위해 C언어에서 구조체에 접근할 때는 `->` 연산자를 사용하는 것을 권장한다. (그럼 `ptr->a`와 같이 편리하게 사용할 수 있다.)

```c
#include <stdio.h>

struct test {
    int a, b;
};

int main() {
    struct test st;
    struct test *ptr;
    ptr = &st;
    (*ptr).a = 1;
    ptr->b = 2;
    printf("st 의 a 멤버 : %d \n", st.a);
    printf("st 의 b 멤버 : %d \n", st.b);
    return 0;
}
```

##### 구조체 멤버인 포인터

다음과 같이 사용할 수 있다.

`pt->pointer`를 통해서 구조체의 멤버인 포인터에 접근하고, `*`를 사용하여 포인터가 참조하는 값을 수정한다.

```c
#include <stdio.h>  
  
struct TEST {  
    int c;  
    int *pointer;  
};  
  
int main() {  
    struct TEST t;  
    struct TEST *pt = &t;  
    int i = 0;  
    t.pointer = &i;  
    *t.pointer = 3;  
    printf("%i \n", *t.pointer);  
    *pt->pointer = 4; // *(pt->pointer) = 4와 동일  
    printf("%i \n", *t.pointer);  
    return 0;  
}
```

반대로 `&pt->c`와 같은 연산도 가능하다. 이런 경우, `add_one(int *a)`처럼 

```c
#include <stdio.h>
int add_one(int *a);
struct TEST {
    int c;
};
int main() {
    struct TEST t;
    struct TEST *pt = &t;

    /* pt 가 가리키는 구조체 변수의 c 멤버의 값을 0 으로 한다*/
    pt->c = 0;

    /*
    add_one 함수의 인자에 t 구조체 변수의 멤버 c 의 주소값을
    전달하고 있다.
    */
    add_one(&t.c);

    printf("t.c : %d \n", t.c);

    /*
    add_one 함수의 인자에 pt 가 가리키는 구조체 변수의 멤버 c
    의 주소값을 전달하고 있다.

    */
    add_one(&pt->c);

    printf("t.c : %d \n", t.c);

    return 0;
}
int add_one(int *a) {
    *a += 1;
    return 0;
}
```

`&` 연산자를 사용하여 변수의 주소를 전달하고, 그 값을 변경하는 걸 볼 수 있다.

##### 추가

다음과 같이 구조체 정의와 선언을 함께 할 수 있다.
```c
#include <stdio.h>  
  
struct HUMAN {  
    int age;  
} Adam = {31}, Eve;  
  
int main() {  
  
    printf("%d \n", Adam.age);  
  
    Eve.age = 42;  
    printf("%d \n", Eve.age);  
  
    return 0;  
}
```

# 공용체(union)

멤버끼리 메모리를 공유한다. 이는 타입이 많아져도 동일하다.

`int`와 `char`가 있다면, `char`가 처음 1byte, `int`가 처음부터 4byte를 점유한다. 즉, 처음 1byte의 값을 공유해서 사용한다. 

이걸 어디에 써? 하고 찾아보니 여러 데이터 타입 중 하나만 유효해도 되는 경우, 메모리 절약 용도로 (통신 프로코톨 메시지 처리) 사용한다고 한다. (사실 이해 잘 못했음)

다만 주의해야 하는게, 엔디언에 따라 값이 달라질 수 있다. `x86`, `x86-64`, `ARM`는 리틀 엔디언을 사용한다.

- **빅 엔디언**: 0x12345678이 메모리에 다음과 같이 저장\: `12 34 56 78`
- **리틀 엔디언**: 0x12345678이 메모리에 다음과 같이 저장: `78 56 34 12`
	- 저장하는 데이터의 "순서"가 반대인거지. 데이터 "값"의 순서는 동일하다. 2byte를 읽으면 `0x5678`이 나오는 식

[엔디언](https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8)

# 열거형(Enum)

다음과 같이 정의할 수 있다.

```c
enum EnumName {
    Value1,
    Value2,
    // ...
};
```

각 요소는 컴파일 시에 정수로 평가된다.

```c
#include <stdio.h>

enum Colors {
    RED = 3,
    BLUE,
    WHITE = 3,
    BLACK
};

int main() {
    enum Colors color;
    
    color = RED;
    printf("RED: %d\n", color);

    color = BLUE;
    printf("BLUE: %d\n", color);

    color = WHITE;
    printf("WHITE: %d\n", color);

    color = BLACK;
    printf("BLACK: %d\n", color);

    return 0;
}

// 출력 결과
RED: 3
BLUE: 4
WHITE: 5
BLACK: 6
```

하지만 다음과 같이 사용한다면 문제가 발생할 수 있기 때문에, Enum 정의 시 정수값을 직접 넣어주는 건 주의해야 할 것 같다.

```c
#include <stdio.h>  
  
enum Colors {  
    RED = 3,  
    BLUE,  
    WHITE = 3,  
    BLACK  
};  
  
int main() {  
    enum Colors color;  
  
    color = RED;  
    if (color == WHITE) {  // color는 RED 임에도 조건문이 true가 된다.
        printf("color is white!"); 
    }  
  
    return 0;  
}
```
# 얕은 복사 깊은 복사

- **일반적인 타입**: 포인터(혹은 주소를 저장하는 타입)가 아닌 값을 직접 저장하는 `int`, `char` 등 기본 데이터 타입은 얕은 복사라는 개념이 없습니다. 이러한 타입은 값 자체를 복사합니다.

- **배열, 구조체**: 배열이나 구조체가 요소나 멤버로 참조(포인터, 배열, 구조체 등)를 가지는 경우, 기본적으로 얕은 복사가 수행된다.
    - **구조체의 경우**:  만약 구조체 멤버 중 포인터(배열, 구조체도 포함)가 포함되어 있다면, 포인터의 값(즉, 메모리 주소)만 복사되며, 포인터가 가리키는 실제 데이터는 복사되지 않는다. 이는 원본과 복사본이 동일한 메모리 주소를 가리키게 되어, 한쪽의 변경이 다른 쪽에도 영향을 미칠 수 있음을 의미한다.
    - **배열의 경우**: 배열은 대입 연산자를 직접 사용할 수 없으므로, `memcpy` 함수나 루프를 사용하여 수동으로 복사한다. 이 경우에도 얕은 복사가 발생한다.


그래서 참조 변수(포인터, 배열, 구조체 등)의 경우, 필요한 경우 의도적으로 깊은 복사를 구현해야 한다.

- **얕은 복사**: 포인터가 가리키는 메모리 주소만 복사하여 원본과 복사본이 동일한 데이터를 공유
- **깊은 복사**: 포인터가 가리키는 실제 데이터까지 모두 복사하여 원본과 복사본이 독립적인 메모리 공간을 가짐

# 변수의 생존 조건 및 데이터 세그먼트 구조

- 전역 변수
	- 가장 바깥(함수 내부 x)에서 변수 선언 시 해당 변수는 전역 변수
	- 전역변수는 기본적으로 0으로 초기화 됨 (초기화 하지 않았을 때)
	- 가능하면 최소한으로 사용하기 (모든 영역에서 접근/수정 가능하므로)
- 지역 변수
	- 함수 내부에서 정의되는 변수, 함수가 종료되면 함께 없어짐
- 정적 변수
	- `static 타입 변수이름 = 값;`으로 정의
	- 초기화는 단 한 번만 수행됨, 이후 호출해도 문제 없음
	- 선언된 범위를 값이 제거되지 않음. (외부에서 접근 가능하다는 소리는 아님)

전역 변수 예시
```c
#include <stdio.h>  
  
int global_var1;  
int global_var2 = 11;  
  
int main() {  
    printf("%d", global_var1);  
    printf("%d", global_var2);  
    return 0;  
}
```

정적 변수 예시
```c
#include <stdio.h>  

int function() {  
    static int how_many_called = 0;  
  
    how_many_called++;  
    printf("function called : %d \n", how_many_called);  
  
    return 0;  
}  
  
int main() {  
    function();  
    function();  
    function();  
    function();  
    return 0;  
}
```


##### 데이터 세그먼트 주소

씹어먹는 C언어를 주로 참고하는데, 입문 강의라서 이게 정확한지는 모르겠다.

다음과 같은 구조를 가진다.

```
+-----------------------+ 높은 주소
|       스택 (Stack)     |
|       ...             |
|   동적 할당 (Heap)      |
|       ...             |
|  Data (전역, 정적 변수)  |
| Read-Only Data(상수, 리터럴) |
|    코드/텍스트           |
+-----------------------+ 낮은 주소
```

# 모듈화

### 헤더 파일, `#include`




# GPT
### [GPT 사용] C언어 함수 호출 과정 어셈블리어로 이해하기 

ARM64 어셈블리어 사용함. (mac m1을 사용하기 때문)

어차피 공통적인 흐름 정도를 알아보기 위한 거니까 ㄱㅊ

```c
#include <stdio.h>

int add(int a, int b);

int main(void) {
    int a = 2;
    int b = 12;

    printf("Result of add(a, b): %d\n", add(a, b));

    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

다음 코드를 CLion의 기능을 사용해 어셈블리어로 번역했다. (`-std=gnu11 -arch arm64 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX13.3.sdk`)
```arm
_main:
	sub	sp, sp, #48             // 스택 포인터를 48바이트 감소시켜 스택 프레임을 설정합니다.
	stp	x29, x30, [sp, #32]     // 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택에 저장합니다.
	add	x29, sp, #32            // 현재 스택 포인터에 32를 더해 프레임 포인터(x29)를 설정합니다.
	mov	w8, #0                  // w8 레지스터에 0을 저장합니다.
	str	w8, [sp, #16]           // w8(0)을 sp+16 위치에 저장합니다.
	stur	wzr, [x29, #-4]     // wzr(0)을 x29-4 위치에 저장합니다.
	mov	w8, #2                  // w8 레지스터에 2를 저장합니다.
	stur	w8, [x29, #-8]      // w8(2)을 x29-8 위치에 저장합니다. (a = 2)
	mov	w8, #12                 // w8 레지스터에 12를 저장합니다.
	stur	w8, [x29, #-12]     // w8(12)을 x29-12 위치에 저장합니다. (b = 12)
	ldur	w0, [x29, #-8]      // x29-8 위치에서 값을 로드하여 w0 레지스터에 저장합니다. (a 값 로드)
	ldur	w1, [x29, #-12]     // x29-12 위치에서 값을 로드하여 w1 레지스터에 저장합니다. (b 값 로드)
	bl	_add                    // add 함수를 호출합니다.
	mov	x9, sp                  // 스택 포인터 값을 x9 레지스터에 저장합니다.
	mov	x8, x0                  // x0 레지스터의 값을 x8 레지스터에 저장합니다.
	str	x8, [x9]                // x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
	adrp	x0, l_.str@PAGE     // 문자열 리터럴 l_.str의 페이지 주소를 x0 레지스터에 로드합니다.
	add	x0, x0, l_.str@PAGEOFF  // 문자열 리터럴 l_.str의 페이지 오프셋을 x0 레지스터에 더합니다.
	bl	_printf                 // printf 함수를 호출합니다.
	ldr	w0, [sp, #16]           // sp+16 위치에서 값을 로드하여 w0 레지스터에 저장합니다.
	ldp	x29, x30, [sp, #32]     // 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
	add	sp, sp, #48             // 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

_add:
	sub	sp, sp, #16             // 스택 포인터를 16바이트 감소시켜 스택 프레임을 설정합니다.
	str	w0, [sp, #12]           // w0 레지스터의 값을 sp+12 위치에 저장합니다.
	str	w1, [sp, #8]            // w1 레지스터의 값을 sp+8 위치에 저장합니다.
	ldr	w8, [sp, #12]           // sp+12 위치에서 값을 로드하여 w8 레지스터에 저장합니다.
	ldr	w9, [sp, #8]            // sp+8 위치에서 값을 로드하여 w9 레지스터에 저장합니다.
	add	w0, w8, w9              // w8과 w9의 값을 더하여 w0 레지스터에 저장합니다.
	add	sp, sp, #16             // 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
	ret                         // 함수에서 리턴합니다.

	.asciz	"Result of add(a, b): %d\n" // 문자열 리터럴
```

##### **중요한 부분 정리**

- main 함수에서부터 Call Stack을 사용하여 처리하는 모습을 볼 수 있다.    

- `add` 함수 호출 시
	- Stack Frame을 정의하고, `w0`, `w1`로 전달받은 매개변수를 Stack에 저장한다.
		- 미리 Stack Pointer를 증가시켜 사용할 Frame(매개변수, Callee 주소, 지역변수)을 공간을 선언한다.   
	- Stack에 저장된 변수를 가져와서 `w8`, `w9`에 저장하고 연산 결과를 `w0`에 저장한다.
	- 이후 SP를 낮춘 후 리턴한다.

- 파일 내 존재하지 않는 함수인 `printf`는 `bl`이라는 명령어로 호출한다.

###### 매개변수 전달 시 Stack에 저장하지 않은 이유
GTP 피셜로는 ARM의 경우 매개변수 4개까지는 함수 호출 시 레지스터를 사용한다고 한다. (반환 시에는 값이 하나이므로 마찬가지로 레지스터를 사용한다. x86의 경우에도 2개까지는 레지스터 (ECX, EDX)를 통해서 전달한다고 한다.)

4개를 넘어가면 스택을 사용한다고 한다.

#### GPT의 해설

##### 함수 호출 전후의 프레임 처리
1. **메인 함수 스택 프레임 설정**:
    - `sub sp, sp, #48`:
        - 스택 포인터를 48바이트 감소시켜 새로운 스택 프레임을 설정합니다. 이 공간은 지역 변수와 함수 호출의 저장 공간으로 사용됩니다.
    - `stp x29, x30, [sp, #32]`:
        - 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 스택의 sp+32 위치에 저장합니다. 이는 함수 호출이 끝난 후 원래의 호출 프레임으로 돌아가기 위해 필요합니다.
    - `add x29, sp, #32`:
        - 현재 스택 포인터 값에 32를 더하여 새로운 프레임 포인터(x29)를 설정합니다. 이제 x29는 현재 함수의 프레임 베이스 포인터가 됩니다.
2. **변수 초기화**:
    - `mov w8, #2` 및 `stur w8, [x29, #-8]`:
        - w8 레지스터에 2를 저장하고, 이를 x29-8 위치에 저장합니다. 이는 변수 `a`를 초기화하는 과정입니다.
    - `mov w8, #12` 및 `stur w8, [x29, #-12]`:
        - w8 레지스터에 12를 저장하고, 이를 x29-12 위치에 저장합니다. 이는 변수 `b`를 초기화하는 과정입니다.
3. **함수 호출 준비**:
    - `ldur w0, [x29, #-8]` 및 `ldur w1, [x29, #-12]`:
        - x29-8 위치의 값을 w0 레지스터에 로드하고, x29-12 위치의 값을 w1 레지스터에 로드합니다. 이는 함수 `add`의 인수 `a`와 `b`를 준비하는 과정입니다.
    - `bl _add`:
        - `add` 함수를 호출합니다. 이때 `w0`와 `w1` 레지스터의 값이 함수의 인수로 전달됩니다.

##### `add` 함수의 스택 프레임 설정 및 해제
4. **`add` 함수 스택 프레임 설정**:
    - `sub sp, sp, #16`:
        - 스택 포인터를 16바이트 감소시켜 새로운 스택 프레임을 설정합니다.
    - `str w0, [sp, #12]` 및 `str w1, [sp, #8]`:
        - `w0` 레지스터의 값을 sp+12 위치에 저장하고, `w1` 레지스터의 값을 sp+8 위치에 저장합니다. 이는 `add` 함수의 인수 `a`와 `b`를 스택에 저장하는 과정입니다.
5. **변수 값 로드 및 덧셈 연산**:
    - `ldr w8, [sp, #12]` 및 `ldr w9, [sp, #8]`:
        - sp+12 위치의 값을 w8 레지스터에 로드하고, sp+8 위치의 값을 w9 레지스터에 로드합니다.
    - `add w0, w8, w9`:
        - w8과 w9의 값을 더하여 w0 레지스터에 저장합니다. 이는 `a + b`의 결과를 계산하는 과정입니다.
6. **`add` 함수의 스택 프레임 해제 및 리턴**:
    - `add sp, sp, #16`:
        - 스택 포인터를 16바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다. 이때 결과 값은 `w0` 레지스터에 저장되어 있습니다.

##### `main` 함수의 나머지 처리
7. **printf 호출 준비 및 호출**:
    - `mov x9, sp` 및 `mov x8, x0`:
        - 스택 포인터 값을 x9 레지스터에 저장하고, `add` 함수의 결과 값을 x8 레지스터에 저장합니다.
    - `str x8, [x9]`:
        - x8의 값을 x9가 가리키는 메모리 위치에 저장합니다.
    - `adrp x0, l_.str@PAGE` 및 `add x0, x0, l_.str@PAGEOFF`:
        - 문자열 리터럴 l_.str의 페이지 주소와 페이지 오프셋을 x0 레지스터에 로드합니다.
    - `bl _printf`:
        - `printf` 함수를 호출합니다.
8. **메인 함수 스택 프레임 해제 및 리턴**:
    - `ldr w0, [sp, #16]`:
        - sp+16 위치의 값을 w0 레지스터에 로드합니다. (사용되지 않는 코드로 보임)
    - `ldp x29, x30, [sp, #32]`:
        - 스택에서 이전 프레임 포인터(x29)와 링크 레지스터(x30)를 복원합니다.
    - `add sp, sp, #48`:
        - 스택 포인터를 48바이트 증가시켜 원래 상태로 복원합니다.
    - `ret`:
        - 함수에서 리턴합니다.
