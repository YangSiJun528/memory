# 메모

대충 먼저 흝어본 후기

- 생각보다 C랑 많이 다르다.
    - low한 부분을 최대한 다루지 않도록 하는게 보임. 고수준 언어에 가까운 느낌.
    - C가 쉬운 어셈블리어라면, C++은 어려운 자바 느낌. (low, high level 언어 차이 느낌)
- 비숫한 기능인에 OO 특화된 타입이나 기능이 많다.
    - 특히 버전 올라가면서 키워드나 타입이 계속 추가되는데, 나무위키보니까 C++이 27 버전까지 있음...
        - `A라는 문제가 있음 -> B로 해결 -> C라는 문제가 생김 -> D로 해결`
        - 근데 B는 예전 해결 방법이라 쓸 수 있는데, 나빠서 사용하면 안됨. 이런게 다른 언어들보다 많아...
    - rust도 대충 보고 타입이 왜이렇게 많나 싶었는데, C++이 더 많은거 같음. 사람들이 rust로 넘어가는 이유를 알 것 같기도 함.

#### 어셈블리어
내가 예전에 공부하면서 배운 내용도 추가한거라, 내 기억이 잘못됐으면 틀린 내용이 있을 수도 있음.

- 어셈블리어 수업을 하는데, 나는 m1(arm64)라서 강의 따라서 x86을 실행을 못함.
	- 대신 어셈블리어 대충 이해하고 있으니까 눈으로만 보고 넘김 - [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
	- rax, eax, ax, ah, al 등 한 레지스터 값을 여러 범위를 설정해서 쓰고 읽을 수 있음.
	- 메모리 영역
		- data, bss 차이
			- 둘다 전역 변수와 정적 변수를 저장.
			- data는 초기화한 영역, 바이너리 파일에 포함되어야 함.
			- bss는 초기화하지 않은 영역, 0으로 초기화됨, 값 자체는 바이너리에 초기화 안됨.
			- bss 사용 이유: 메모리 사용량 감소(바이너리 파일에 안씀), 프로그램의 초기 로드 시간 단축(별도 값 로드할 필요 없음)
			- data 사용 이유
				- 초기값 미리 설정, 상수 설정을 통한 메모리/성능 최적화
				- GPT 피셜
					- `bss` 영역은 초기값이 필요 없는 변수들을 저장하지만, 초기값이 필요한 변수들을 `bss` 영역에 저장할 경우 프로그램 시작 시 값을 설정하는 추가 코드가 필요합니다. 이는 프로그램의 초기화 단계에서 성능 저하를 일으킬 수 있습니다.
				    - `data` 영역에 초기화된 값들을 저장하면, 운영체제가 프로그램 로딩 시 메모리에 이미 초기화된 값을 로드하므로 초기화 시간이 절약됩니다.
			- 둘 다 메모리/성능 면에서 최적화를 위함임.
				- 예전에는 메모리 비용이 정말 비싸서 이런 식으로 최적화(파일 크기 줄이기 등) 해야 했음.
			- C/C++ 입장에서 코드 상으로 초기화되는 값이면 data, 아니면 bss로 정의됨. (전역이나 상수만 해당. 지역변수는 stack에 저장되므로)
		- 메모리는 하나의 큰 1차원 배열이다. (가상 메모리가 가능하게 해줌)
	- 어셈블리어는 데이터 타입이나 그런거 없이 레지스터, 메모리 쓰기/읽기 + 연산 기능을 제공함.
- 비트와 바이트
	- (관련해서 생각나서 내가 추가한 내용): 패딩
		- 64비트 컴퓨터에서 CPU는 한 번에 64비트(8바이트)를 읽고 쓰는 것이 가장 효율적입니다. 이는 CPU의 데이터 버스 폭이 64비트이기 때문입니다. 따라서 64비트 컴퓨터에서는 데이터를 64비트(또는 그 배수) 단위로 정렬하는 것이 성능상 이점이 있습니다.
		- 패딩: 64비트 컴퓨터에서 데이터를 효율적으로 읽고 쓰기 위해서는 데이터가 8바이트 경계에 맞추어 정렬되어야 합니다. C 구조체에서 패딩은 이러한 정렬을 맞추기 위해 삽입됩니다. 패딩을 통해 CPU가 데이터에 효율적으로 접근할 수 있으며, 이는 전체적인 성능 향상으로 이어집니다. 
			- 단점: 패딩은 메모리 내에서의 데이터 정렬과 접근 효율성을 높이기 위해 사용되지만, 패딩은 실제 데이터가 아니기 때문에 메모리 낭비로 이어질 수 있습니다. 특히, 네트워크를 통해 데이터를 송수신할 때는 패딩을 포함시키면 불필요하게 전송 데이터가 커져서 비효율적입니다. 따라서 패딩을 제거하고 송수신하는 것이 일반적입니다. (주로 직렬화/역직렬화 사용)
		- [1. C 기초 정리](../../c_with_%20data_structure/1.%20C%20기초%20정리.md)의 "구조체 패딩" 참고
- 음수와 양수의 비트 표현(2의 보수), 2/8/10/16 진수, 부동소수점 표현 등
	- 근데 강의 설명이 가볍게 다루는거라 책처럼 체계적이진 않음. 대충 알고 있는 입장에서는 빨리 넘어가니까 좋긴 함. C++ 문법하고는 엄청 직접적으로 관련있는 건 아니니까. (그래도 알아야 잘 쓰긴 하는데, 모든 언어에 통용되는 개념이라)
- 문자(ASCII)와 엔디안
	- ASCII와 UTF-8은 호환, 다른 UTF-N이랑은 안되는 것도 있음.
	- 리틀 엔디안, 빅 엔디안은 서로 장단점이 반대임
		- 리틀: 특정 데이터에서 초기 값만 읽을 때 처음부터 조금만 읽으면 되서 유리함
			- 초기 값 접근/수정의 용의성
		- 빅: 데이터의 크기(범위)를 빠르게 비교 가능
			- 데이터 크기 비교의 용이성
- 사칙연산
	- Nand2Tetris랑 문법만 다르지 간단한 동작은 비슷하긴 함.
		- 다른 점은 곱셉/나눗셈이 ALU에 포함되어 있고, 대신 특정 레지스터 값에 결과가 저장되는 등 덧셈/뺄셈과 다름. 아마 최적화되어있어서 일반적인 방식과 다른듯? (정확하진 않음. 추측)
- 시프트, 논리(AND, OR ...)
	- shift 비트를 우/좌측으로 옮김. 연산이 빨라서 최적화에 사용. (2의 배수 연산, 한 칸 당2배 or 1/2배로 줄일 수 있음. 시프트 시 값을 날리는 특징을 이용하기도 함)
		- 논리적 시프트: 부호 비트 상관없이 전체를 시프트함
		- 산술 시프트: 부호 비트를 유지하며 시프트, 그래서 좌측 시프트 + 오버플로우 발생 시 값이 2배수 연산임을 보장 못함. 
	- 논리 연산
		- and는 bitflag(bit가 일종의 논리적인 값, 메모리 효율적인 bool)에서 사용됨. 아니면 subnet mask나
		- xor은 동일한 값으로 2번 사용하면 값이 원본으로 되돌아오는 특징. 대칭키 암호화에서 사용됨. 본인은 xor하면 값을 0으로 초기화 가능. 0으로 할당하는 것보다 더 빠름. (어셈블러 관점에서 생각해보기)
- 분기/반복문
	- 이미 정리한거고, 알고 있는 내용이니까 정리는 안함.
	- 대충 점프, 비교 기능을 사용해서 구현됨.
	- [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
- 배열(array)과 주소
	- array(list아님)은 연속된 메모리 주소에 저장된 데이터
	- array의 주소는 array의 시작 지점을 봄, random access
	- 대충 아니까 정리 스킵
- 함수
	- 어셈블리어 입장에서는 걍 코드 중 하나.
	- 레지스터나 stack pointer에 파라미터+호출자 정보 넣고 함수 정의된 곳으로 jump (ip(다음 연산 주소를 가리키는 포인터)값이 변경됨.)
		- stack이라는 메모리 공간을 사용, heap,stack,bss,data에서 말하는 그 stack 맞음.
		- 반복되는 함수 호출 시 호출자의 정보를 가지고 있기 위해서 + 함수 수행 시 일시적으로 존재하는 local 값을 다루기 위해서
			- 이런 함수 호출 시 sp에 쌓이는 데이터의 집합을 stack frame이라고 함.
				- 일반적으로 `리턴 주소 + 파라미터1,2,3 + 로컬 변수 + 기타 정보` 를 저장함. 순서는 잘 모르겠음.
				- x86에선 반환 값을 rax(레지스터, 꼭 rax가 아닐수도 있음)를 저장함. 반환 시 sp, ip 값을 알맞게 변경함. 
	- x86 어셈블리어에서는 rbp라고 stack frame의 시작 지점을 고정해서 보고 있는 레지스터가 있음.
		- sp는 계속 변하기 때문에 그렇다고 함.
		- rbp를 사용해서 파라미터, 로컬 변수 값에 상대적인 접근을 쉽게 함.
	- 처리하고 기존 데이터 제거(포인터 값 이동, 실제로 제거하는 건 아님)하고 sp에 반환 결과 담고 호출된 주소로 다시 이동
