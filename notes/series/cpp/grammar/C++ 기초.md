# 메모

대충 C++ (강의 아님) 먼저 흝어본 후기

- 생각보다 C랑 많이 다르다.
    - low한 부분을 최대한 다루지 않도록 하는게 보임. 고수준 언어에 가까운 느낌.
    - C가 쉬운 어셈블리어라면, C++은 어려운 자바 느낌. (low, high level 언어 차이 느낌)
- 비숫한 기능인에 OO 특화된 타입이나 기능이 많다.
    - 특히 버전 올라가면서 키워드나 타입이 계속 추가되는데, 나무위키보니까 C++이 27 버전까지 있음...
        - `A라는 문제가 있음 -> B로 해결 -> C라는 문제가 생김 -> D로 해결`
        - 근데 B는 예전 해결 방법이라 쓸 수 있는데, 나빠서 사용하면 안됨. 이런게 다른 언어들보다 많아...
    - rust도 대충 보고 타입이 왜이렇게 많나 싶었는데, C++이 더 많은거 같음. 사람들이 rust로 넘어가는 이유를 알 것 같기도 함.

#### 어셈블리어
내가 예전에 공부하면서 배운 내용도 추가한거라, 내 기억이 잘못됐으면 틀린 내용이 있을 수도 있음.

그리고 이후에 기능 설명하면서 C++ 코드로 생성한 어셈블리어를 설명하는데, Nand2Tetris나 이후에 어셈블리어 찾아본 내용이랑 거의 동일해서 정리는 안함.

- 어셈블리어 수업을 하는데, 나는 m1(arm64)라서 강의 따라서 x86을 실행을 못함.
	- 대신 어셈블리어 대충 이해하고 있으니까 눈으로만 보고 넘김 - [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
	- rax, eax, ax, ah, al 등 한 레지스터 값을 여러 범위를 설정해서 쓰고 읽을 수 있음.
	- 메모리 영역
		- data, bss 차이
			- 둘다 전역 변수와 정적 변수를 저장.
			- data는 초기화한 영역, 바이너리 파일에 포함되어야 함.
			- bss는 초기화하지 않은 영역, 0으로 초기화됨, 값 자체는 바이너리에 초기화 안됨.
			- bss 사용 이유: 메모리 사용량 감소(바이너리 파일에 안씀), 프로그램의 초기 로드 시간 단축(별도 값 로드할 필요 없음)
			- data 사용 이유
				- 초기값 미리 설정, 상수 설정을 통한 메모리/성능 최적화
				- GPT 피셜
					- `bss` 영역은 초기값이 필요 없는 변수들을 저장하지만, 초기값이 필요한 변수들을 `bss` 영역에 저장할 경우 프로그램 시작 시 값을 설정하는 추가 코드가 필요합니다. 이는 프로그램의 초기화 단계에서 성능 저하를 일으킬 수 있습니다.
				    - `data` 영역에 초기화된 값들을 저장하면, 운영체제가 프로그램 로딩 시 메모리에 이미 초기화된 값을 로드하므로 초기화 시간이 절약됩니다.
			- 둘 다 메모리/성능 면에서 최적화를 위함임.
				- 예전에는 메모리 비용이 정말 비싸서 이런 식으로 최적화(파일 크기 줄이기 등) 해야 했음.
			- C/C++ 입장에서 코드 상으로 초기화되는 값이면 data, 아니면 bss로 정의됨. (전역이나 상수만 해당. 지역변수는 stack에 저장되므로)
		- 메모리는 하나의 큰 1차원 배열이다. (가상 메모리가 가능하게 해줌)
	- 어셈블리어는 데이터 타입이나 그런거 없이 레지스터, 메모리 쓰기/읽기 + 연산 기능을 제공함.
- 비트와 바이트
	- (관련해서 생각나서 내가 추가한 내용): 패딩
		- 64비트 컴퓨터에서 CPU는 한 번에 64비트(8바이트)를 읽고 쓰는 것이 가장 효율적입니다. 이는 CPU의 데이터 버스 폭이 64비트이기 때문입니다. 따라서 64비트 컴퓨터에서는 데이터를 64비트(또는 그 배수) 단위로 정렬하는 것이 성능상 이점이 있습니다.
		- 패딩: 64비트 컴퓨터에서 데이터를 효율적으로 읽고 쓰기 위해서는 데이터가 8바이트 경계에 맞추어 정렬되어야 합니다. C 구조체에서 패딩은 이러한 정렬을 맞추기 위해 삽입됩니다. 패딩을 통해 CPU가 데이터에 효율적으로 접근할 수 있으며, 이는 전체적인 성능 향상으로 이어집니다. 
			- 단점: 패딩은 메모리 내에서의 데이터 정렬과 접근 효율성을 높이기 위해 사용되지만, 패딩은 실제 데이터가 아니기 때문에 메모리 낭비로 이어질 수 있습니다. 특히, 네트워크를 통해 데이터를 송수신할 때는 패딩을 포함시키면 불필요하게 전송 데이터가 커져서 비효율적입니다. 따라서 패딩을 제거하고 송수신하는 것이 일반적입니다. (주로 직렬화/역직렬화 사용)
		- [1. C 기초 정리](../../c_with_%20data_structure/1.%20C%20기초%20정리.md)의 "구조체 패딩" 참고
- 음수와 양수의 비트 표현(2의 보수), 2/8/10/16 진수, 부동소수점 표현 등
	- 근데 강의 설명이 가볍게 다루는거라 책처럼 체계적이진 않음. 대충 알고 있는 입장에서는 빨리 넘어가니까 좋긴 함. C++ 문법하고는 엄청 직접적으로 관련있는 건 아니니까. (그래도 알아야 잘 쓰긴 하는데, 모든 언어에 통용되는 개념이라)
- 문자(ASCII)와 엔디안
	- ASCII와 UTF-8은 호환, 다른 UTF-N이랑은 안되는 것도 있음.
	- 리틀 엔디안, 빅 엔디안은 서로 장단점이 반대임
		- 리틀: 특정 데이터에서 초기 값만 읽을 때 처음부터 조금만 읽으면 되서 유리함
			- 초기 값 접근/수정의 용의성
		- 빅: 데이터의 크기(범위)를 빠르게 비교 가능
			- 데이터 크기 비교의 용이성
- 사칙연산
	- Nand2Tetris랑 문법만 다르지 간단한 동작은 비슷하긴 함.
		- 다른 점은 곱셉/나눗셈이 ALU에 포함되어 있고, 대신 특정 레지스터 값에 결과가 저장되는 등 덧셈/뺄셈과 다름. 아마 최적화되어있어서 일반적인 방식과 다른듯? (정확하진 않음. 추측)
- 시프트, 논리(AND, OR ...)
	- shift 비트를 우/좌측으로 옮김. 연산이 빨라서 최적화에 사용. (2의 배수 연산, 한 칸 당2배 or 1/2배로 줄일 수 있음. 시프트 시 값을 날리는 특징을 이용하기도 함)
		- 논리적 시프트: 부호 비트 상관없이 전체를 시프트함
		- 산술 시프트: 부호 비트를 유지하며 시프트, 그래서 좌측 시프트 + 오버플로우 발생 시 값이 2배수 연산임을 보장 못함. 
	- 논리 연산
		- and는 bitflag(bit가 일종의 논리적인 값, 메모리 효율적인 bool)에서 사용됨. 아니면 subnet mask나
		- xor은 동일한 값으로 2번 사용하면 값이 원본으로 되돌아오는 특징. 대칭키 암호화에서 사용됨. 본인은 xor하면 값을 0으로 초기화 가능. 0으로 할당하는 것보다 더 빠름. (어셈블러 관점에서 생각해보기)
- 분기/반복문
	- 이미 정리한거고, 알고 있는 내용이니까 정리는 안함.
	- 대충 점프, 비교 기능을 사용해서 구현됨.
	- [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
- 배열(array)과 주소
	- array(list아님)은 연속된 메모리 주소에 저장된 데이터
	- array의 주소는 array의 시작 지점을 봄, random access
	- 대충 아니까 정리 스킵
- 함수
	- 어셈블리어 입장에서는 걍 코드 중 하나.
	- 레지스터나 stack pointer에 파라미터+호출자 정보 넣고 함수 정의된 곳으로 jump (ip(다음 연산 주소를 가리키는 포인터)값이 변경됨.)
		- stack이라는 메모리 공간을 사용, heap,stack,bss,data에서 말하는 그 stack 맞음.
		- 반복되는 함수 호출 시 호출자의 정보를 가지고 있기 위해서 + 함수 수행 시 일시적으로 존재하는 local 값을 다루기 위해서
			- 이런 함수 호출 시 sp에 쌓이는 데이터의 집합을 stack frame이라고 함.
				- 일반적으로 `리턴 주소 + 파라미터1,2,3 + 로컬 변수 + 기타 정보` 를 저장함. 순서는 잘 모르겠음.
				- x86에선 반환 값을 rax(레지스터, 꼭 rax가 아닐수도 있음)를 저장함. 반환 시 sp, ip 값을 알맞게 변경함. 
	- x86 어셈블리어에서는 rbp라고 stack frame의 시작 지점을 고정해서 보고 있는 레지스터가 있음.
		- sp는 계속 변하기 때문에 그렇다고 함.
		- rbp를 사용해서 파라미터, 로컬 변수 값에 상대적인 접근을 쉽게 함.
	- 처리하고 기존 데이터 제거(포인터 값 이동, 실제로 제거하는 건 아님)하고 sp에 반환 결과 담고 호출된 주소로 다시 이동

### C++ 시작
- 정수
	- signed, unsigned, int, short, long ...
		- unsigned기준 char 256, short 6.5만 int 42억, longlong(8바이트) 매우 크다.
		- unsigned는 signed 간 변환 등 여러 문제 때문에, 팀마다 호불호가 있다고 함.
	- 오버플로우 언더플로우
	- 주석
	- bss, data 영역의 변수
- 불리언과 실수(부동소수점)
	- bool - 1바이트
		- 컴퓨터 입장에서 비트 단위의 관리, I/O가 불가능하거나 어렵기 때문
		- 어셈블리 입장에서는 그냥 정수 0 or 1을 비교함. 
		- char 같은거 대신 쓰는 이유는 가독성/유지보수성 때문에 사용한다고 보면 됨.
	- 부동소수점(floating-point)
		- IEEE 754 표준 참고
		- 소수점 위치가 고정되지 않는 숫자
		- 데이터 크기 대비 큰 범위를 표시 가능
		- 단 값의 누락 발생, 근사값임. `==` 시 주의, 반복 연산 시 늘어나는 오차범위 주의
		- float(4바이트, 6~9자리까지 유효), double(8바이트, 소수점 15~17자리까지 유효)
		- GPT 정리
			- **지수 (Exponent)**: 숫자의 크기를 조정하며, 2의 지수승으로 표현됩니다.
			- **가수 (Mantissa)**: 숫자의 정밀도를 나타내며, 1.xxxx 형태로 저장됩니다.
			- **구조**: `float`과 `double`은 각각 1비트의 부호, 8/11비트의 지수, 23/52비트의 가수로 구성됩니다.
- 문자와 문자열
	- char: 내부적으로는 정수임. (더하기, 빼기 등 연산 가능) 근데 ASCII 문자랑 대응됨. 
		- 0~127를 넘는 값, 음수나 더 큰 값을 사용하면 이상한 문자가 출력됨. 
	- Unicode -> UTF8,UTF16 장단점 - 위에 설명 있음. 아니면 검색하던가
	- 문자열: 문자 배열, string 자료형은 문자 배열 + 문자열 관련 기능 추가 
		- char 배열의 마지막에는 끝임을 알리기 위해서 00(NULL)이 있어야 함.
- 산술 연산
	- `=`, `()`, `+, -, *, /, %`, `+=, -=, %=, /=`, `++, --`(이거는 `++a` 처럼 앞에 있는게 약간 빠름)
- 비교/논리 연산
	- 특정 조건/상태 확인
	- [불 대수](https://ko.wikipedia.org/wiki/%EB%B6%88_%EB%8C%80%EC%88%98)
	- 단락 평가(short-circuit evaluation): 조건문 만족하면 나머지 스킵하는 거
		- 어셈블리어 까서 보여줌.
- 비트 연산
	- `~(not), &, |, ^(xor), <<, >>`
		- `1 << 3` 1을 3번 왼쪽(<<)으로 시프트
	- C++에서 시프트
		- 왼쪽 시프트 (<<)
			- **모든 타입에 대해 논리적 시프트**: 비트를 왼쪽으로 이동시키고, 오른쪽에 0을 채웁니다.
			- 부호 있는 정수에서도 논리적 시프트를 사용하지만, 이는 부호 비트가 이동될 수 있음을 의미하며, 결과적으로 값의 부호가 바뀔 수 있습니다.
		- 오른쪽 시프트 (>>)
			- **부호 없는 정수 (unsigned integers)에 대해 논리적 시프트**: 비트를 오른쪽으로 이동시키고, 왼쪽에 0을 채웁니다.
			- **부호 있는 정수 (signed integers)에 대해 산술적 시프트**: 비트를 오른쪽으로 이동시키고, 왼쪽에 부호 비트(기존 최상위 비트 값)를 채웁니다. 대부분의 컴파일러에서 부호 있는 정수에 대해 산술적 시프트를 수행합니다.
				- 음수(앞이 1)를 >> 하는 경우 1001이면 1100이 된다.
				- 부호에 따라서 0/1 여부가 달라짐.
	- BitFlag: Bit로 상태(Flag) 표시
	- BitMask: BitFlag의 원하는 값을 뽑아내는 Mask
- const와 메모리 구조
	- const: 초기화와 할당이 동시에 수행, 수정 불가능
		- 특정 하드코딩된 값에 문맥을 제공해줄 수 있음.
	- 메모리 구조
		- .data: 초기화된 고정(전역, 상수)
		- .bss: 초기화 안된 전역. (그 외 있을 수도?)
		- .rodata: 읽기 전용 영역 (const pointer 등)
		- stack: 지역변수, 콜스택
		- heap: 동적 영역
		- 메모리 영역에 대한 구체적인 C++의 표준이 없음. 정확한건 컴파일러 하기 나름.
- 유의사항
	- 변수의 유효범위: 같은 변수 이름을 사용하는 경우 등
		- 이름 변경, `{}`를 사용한 스코프 제한 등
	- 연산 우선순위: 가독성, 명확성을 위해 `()` 사용하기
	- 타입 변환: 
		- 작은 범위와 넒은 범위의 연산 시 넒은 범위로 변환 (암시적 형변환)
		- (특히 int와 float는 둘다 같은 바이트지만 float는 더 넒은 범위 표현이 가능하므로 변환됨)
		- 큰 범위를 작은 범위로 변경하는 경우 데이터 분실 주의 (상위 비트 그대로 없어짐)
		- signed, unsigned 사이 간 연산 주의
	- 연산
		- 0으로 나누기
		- 오버/언더플로우
		- 부동소수점 정밀도
### 코드의 흐름 제어
- 분기문
	- 꼭 true(1)이나 flase(0)이 아니여도 됨. 0이 아니면 true로 판단함.
	- `if-else, switch-case`
		- `switch-case`는 특정(연속된(gap이 적은) 상수 값, Enum) 경우 점프 테이블을 생성해 O(1)로 효율적이다.
			- 아닌 경우 `if-else`와 비슷하게 동작함.
- 반복문
	- `while, do-while, for`
	- `continue, break`
- 연습문제(별찍기와 구구단) & 가위바위보
	- 간단한 입출력 문제 구현
	- 컴퓨터의 rand는 구현하기 어렵다. 사실 대부분의 rand 기능은 정말 "랜덤"하다고 보기 어렵다. seed 값을 설정하는 식인데, 이걸 매번 바뀌는 컴퓨터의 상태 or 시간 정보를 가공해서 예측하기 어렵게 한다.
- 열거형
	- `enum`
		- 컴파일 시점에 상수 int로 변경
		- 숫자를 지정 안하면 0부터 시작
			- 다음 숫자는 이전숫자 + 1
		- `0, 1, 2, 0(0으로 설정), 1, 2` 같은 경우도 됨.
			- 이 경우 0번째 값과 3번째 값이 동등(`==`)하게 처리됨.
			- 그냥 숫자 0이랑 비교해도 됨.
			- enum의 내부 동작을 이해하는 용도로, 실제로는 관리가 어려우므로 추천하는 방식은 아님.
	- define 매크로
		- enum 역할을 이걸로도 수행 가능.
		- 그러나 매크로는 추천하지 않는다는 내용.
		- 그대로 대체하는 것이라서 연산자 우선순위 등을 고려하지 않음.
			- enum 대비 IDE의 지원을 받기 어려움
### 함수
- 함수 기초
	- 정리할거 딱히 없음
- 스택 프레임
	- 어셈블리어에서 이미 다루기도 했고, 알고 있는 내용이므로 스킵
	- 구조 - 높은 곳 -> 낮은 곳으로 늘어남
		- (높은 곳)
		- 매개변수 - 0번째
		- 반환주소 - 1번째
		- 지역변수 - 2번째
		- (낮은 곳)
- 지역 변수와 값 전달
	- 지역변수: 스택에 올라감, 콜스택 끝나면 유효하지 않음.
	- 전역변수: 다른 영역(data, bss 등)에 들어감. 모든 영역에서 접근/변경 가능하므로 사용에 주의
	- 값 전달: 스택에 값 자체를 넘겨주므로 호출자에게 영향이 가지 않음.
		- call by value/reference 관련 내용
		- 나는 따지고 보면 포인터도 값이라고 생각하는데, 포인터를 포함해서 조금 특별한 값 들을 reference라고 정의한다고 생각하고 있음.
- 호출(콜) 스택
	- 함수 선언: 함수 간의 호출을 쉽게하기 위해서 함수의 시그니처를 미리 정의해 주어야 한다.
	- 호출 스택
		- 호출 스택을 통해서 특정 함수가 어떤 함수로부터 호출되었는지 확인 가능.
		- 디버거에서 호출 스택 정보를 확인할 수 있다.
- 함수 마무리
	- 오버로딩 (C는 지원 안하는데 C++은 지원함)
		- 반환 형식과 이름이 같은 함수(시그니처(파라미터 개수, 타입)가 다름)가 여러개
		- 근데 이거 [씹어먹는 C++](https://modoocode.com/135)보면 더 자세함. (대충 자동으로 끼워 맞출 수 있는 타입이면 형변환해서 끼워준다는 내용)
	- 함수 기본값
		- 기본값이 설정된 매개변수가 맨 끝쪽에 있어야 함.
		- 대신 named parameter 처럼 자유롭지는 않음.
	- stack overflow
		- 스택 프레임이 너무 많이 쌓여서, 컴파일 시점에 정해짐 스택 영역이 다 차버려서 더 호출을 못하면 발생하는 에러
- TextRPG
	- https://gist.github.com/YangSiJun528/d6dd3e4f8d43d31250e51189f9ec1359 에 만든거 정리
	- 간단한 텍스트 게임.
	- 구조체를 사용한 개선
		- 구조체는 모두가 같은 타입이 아닐 때, 패딩이 생겨서 더 큰 크기를 가진다. (컴퓨터가 계산하기 쉽게 함, 컴파일러에 따라 차이가 있을 수 있음 == 표준이 아님)
	- 클래스의 필요성을 보여주는 부분인듯?
### 포인터
- 
