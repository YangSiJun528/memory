# 메모

대충 C++ (강의 아님) 먼저 흝어본 후기

- 생각보다 C랑 많이 다르다.
    - low한 부분을 최대한 다루지 않도록 하는게 보임. 고수준 언어에 가까운 느낌.
    - C가 쉬운 어셈블리어라면, C++은 어려운 자바 느낌. (low, high level 언어 차이 느낌)
- 비숫한 기능인에 OO 특화된 타입이나 기능이 많다.
    - 특히 버전 올라가면서 키워드나 타입이 계속 추가되는데, 나무위키보니까 C++이 27 버전까지 있음...
        - `A라는 문제가 있음 -> B로 해결 -> C라는 문제가 생김 -> D로 해결`
        - 근데 B는 예전 해결 방법이라 쓸 수 있는데, 나빠서 사용하면 안됨. 이런게 다른 언어들보다 많아...
    - rust도 대충 보고 타입이 왜이렇게 많나 싶었는데, C++이 더 많은거 같음. 사람들이 rust로 넘어가는 이유를 알 것 같기도 함.

#### 어셈블리어
내가 예전에 공부하면서 배운 내용도 추가한거라, 내 기억이 잘못됐으면 틀린 내용이 있을 수도 있음.

그리고 이후에 기능 설명하면서 C++ 코드로 생성한 어셈블리어를 설명하는데, Nand2Tetris나 이후에 어셈블리어 찾아본 내용이랑 거의 동일해서 정리는 안함.

- 어셈블리어 수업을 하는데, 나는 m1(arm64)라서 강의 따라서 x86을 실행을 못함.
	- 대신 어셈블리어 대충 이해하고 있으니까 눈으로만 보고 넘김 - [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
	- rax, eax, ax, ah, al 등 한 레지스터 값을 여러 범위를 설정해서 쓰고 읽을 수 있음.
	- 메모리 영역
		- data, bss 차이
			- 둘다 전역 변수와 정적 변수를 저장.
			- data는 초기화한 영역, 바이너리 파일에 포함되어야 함.
			- bss는 초기화하지 않은 영역, 0으로 초기화됨, 값 자체는 바이너리에 초기화 안됨.
			- bss 사용 이유: 메모리 사용량 감소(바이너리 파일에 안씀), 프로그램의 초기 로드 시간 단축(별도 값 로드할 필요 없음)
			- data 사용 이유
				- 초기값 미리 설정, 상수 설정을 통한 메모리/성능 최적화
				- GPT 피셜
					- `bss` 영역은 초기값이 필요 없는 변수들을 저장하지만, 초기값이 필요한 변수들을 `bss` 영역에 저장할 경우 프로그램 시작 시 값을 설정하는 추가 코드가 필요합니다. 이는 프로그램의 초기화 단계에서 성능 저하를 일으킬 수 있습니다.
				    - `data` 영역에 초기화된 값들을 저장하면, 운영체제가 프로그램 로딩 시 메모리에 이미 초기화된 값을 로드하므로 초기화 시간이 절약됩니다.
			- 둘 다 메모리/성능 면에서 최적화를 위함임.
				- 예전에는 메모리 비용이 정말 비싸서 이런 식으로 최적화(파일 크기 줄이기 등) 해야 했음.
			- C/C++ 입장에서 코드 상으로 초기화되는 값이면 data, 아니면 bss로 정의됨. (전역이나 상수만 해당. 지역변수는 stack에 저장되므로)
		- 메모리는 하나의 큰 1차원 배열이다. (가상 메모리가 가능하게 해줌)
	- 어셈블리어는 데이터 타입이나 그런거 없이 레지스터, 메모리 쓰기/읽기 + 연산 기능을 제공함.
- 비트와 바이트
	- (관련해서 생각나서 내가 추가한 내용): 패딩
		- 64비트 컴퓨터에서 CPU는 한 번에 64비트(8바이트)를 읽고 쓰는 것이 가장 효율적입니다. 이는 CPU의 데이터 버스 폭이 64비트이기 때문입니다. 따라서 64비트 컴퓨터에서는 데이터를 64비트(또는 그 배수) 단위로 정렬하는 것이 성능상 이점이 있습니다.
		- 패딩: 64비트 컴퓨터에서 데이터를 효율적으로 읽고 쓰기 위해서는 데이터가 8바이트 경계에 맞추어 정렬되어야 합니다. C 구조체에서 패딩은 이러한 정렬을 맞추기 위해 삽입됩니다. 패딩을 통해 CPU가 데이터에 효율적으로 접근할 수 있으며, 이는 전체적인 성능 향상으로 이어집니다. 
			- 단점: 패딩은 메모리 내에서의 데이터 정렬과 접근 효율성을 높이기 위해 사용되지만, 패딩은 실제 데이터가 아니기 때문에 메모리 낭비로 이어질 수 있습니다. 특히, 네트워크를 통해 데이터를 송수신할 때는 패딩을 포함시키면 불필요하게 전송 데이터가 커져서 비효율적입니다. 따라서 패딩을 제거하고 송수신하는 것이 일반적입니다. (주로 직렬화/역직렬화 사용)
		- [1. C 기초 정리](../../c_with_%20data_structure/1.%20C%20기초%20정리.md)의 "구조체 패딩" 참고
- 음수와 양수의 비트 표현(2의 보수), 2/8/10/16 진수, 부동소수점 표현 등
	- 근데 강의 설명이 가볍게 다루는거라 책처럼 체계적이진 않음. 대충 알고 있는 입장에서는 빨리 넘어가니까 좋긴 함. C++ 문법하고는 엄청 직접적으로 관련있는 건 아니니까. (그래도 알아야 잘 쓰긴 하는데, 모든 언어에 통용되는 개념이라)
- 문자(ASCII)와 엔디안
	- ASCII와 UTF-8은 호환, 다른 UTF-N이랑은 안되는 것도 있음.
	- 리틀 엔디안, 빅 엔디안은 서로 장단점이 반대임
		- 리틀: 특정 데이터에서 초기 값만 읽을 때 처음부터 조금만 읽으면 되서 유리함
			- 초기 값 접근/수정의 용의성
		- 빅: 데이터의 크기(범위)를 빠르게 비교 가능
			- 데이터 크기 비교의 용이성
- 사칙연산
	- Nand2Tetris랑 문법만 다르지 간단한 동작은 비슷하긴 함.
		- 다른 점은 곱셉/나눗셈이 ALU에 포함되어 있고, 대신 특정 레지스터 값에 결과가 저장되는 등 덧셈/뺄셈과 다름. 아마 최적화되어있어서 일반적인 방식과 다른듯? (정확하진 않음. 추측)
- 시프트, 논리(AND, OR ...)
	- shift 비트를 우/좌측으로 옮김. 연산이 빨라서 최적화에 사용. (2의 배수 연산, 한 칸 당2배 or 1/2배로 줄일 수 있음. 시프트 시 값을 날리는 특징을 이용하기도 함)
		- 논리적 시프트: 부호 비트 상관없이 전체를 시프트함
		- 산술 시프트: 부호 비트를 유지하며 시프트, 그래서 좌측 시프트 + 오버플로우 발생 시 값이 2배수 연산임을 보장 못함. 
	- 논리 연산
		- and는 bitflag(bit가 일종의 논리적인 값, 메모리 효율적인 bool)에서 사용됨. 아니면 subnet mask나
		- xor은 동일한 값으로 2번 사용하면 값이 원본으로 되돌아오는 특징. 대칭키 암호화에서 사용됨. 본인은 xor하면 값을 0으로 초기화 가능. 0으로 할당하는 것보다 더 빠름. (어셈블러 관점에서 생각해보기)
- 분기/반복문
	- 이미 정리한거고, 알고 있는 내용이니까 정리는 안함.
	- 대충 점프, 비교 기능을 사용해서 구현됨.
	- [실제 어셈블리어 흝어보기](../../nand2tetris/실제%20어셈블리어%20흝어보기.md)
- 배열(array)과 주소
	- array(list아님)은 연속된 메모리 주소에 저장된 데이터
	- array의 주소는 array의 시작 지점을 봄, random access
	- 대충 아니까 정리 스킵
- 함수
	- 어셈블리어 입장에서는 걍 코드 중 하나.
	- 레지스터나 stack pointer에 파라미터+호출자 정보 넣고 함수 정의된 곳으로 jump (ip(다음 연산 주소를 가리키는 포인터)값이 변경됨.)
		- stack이라는 메모리 공간을 사용, heap,stack,bss,data에서 말하는 그 stack 맞음.
		- 반복되는 함수 호출 시 호출자의 정보를 가지고 있기 위해서 + 함수 수행 시 일시적으로 존재하는 local 값을 다루기 위해서
			- 이런 함수 호출 시 sp에 쌓이는 데이터의 집합을 stack frame이라고 함.
				- 일반적으로 `리턴 주소 + 파라미터1,2,3 + 로컬 변수 + 기타 정보` 를 저장함. 순서는 잘 모르겠음.
				- x86에선 반환 값을 rax(레지스터, 꼭 rax가 아닐수도 있음)를 저장함. 반환 시 sp, ip 값을 알맞게 변경함. 
	- x86 어셈블리어에서는 rbp라고 stack frame의 시작 지점을 고정해서 보고 있는 레지스터가 있음.
		- sp는 계속 변하기 때문에 그렇다고 함.
		- rbp를 사용해서 파라미터, 로컬 변수 값에 상대적인 접근을 쉽게 함.
	- 처리하고 기존 데이터 제거(포인터 값 이동, 실제로 제거하는 건 아님)하고 sp에 반환 결과 담고 호출된 주소로 다시 이동

### C++ 시작
- 정수
	- signed, unsigned, int, short, long ...
		- unsigned기준 char 256, short 6.5만 int 42억, longlong(8바이트) 매우 크다.
		- unsigned는 signed 간 변환 등 여러 문제 때문에, 팀마다 호불호가 있다고 함.
	- 오버플로우 언더플로우
	- 주석
	- bss, data 영역의 변수
- 불리언과 실수(부동소수점)
	- bool - 1바이트
		- 컴퓨터 입장에서 비트 단위의 관리, I/O가 불가능하거나 어렵기 때문
		- 어셈블리 입장에서는 그냥 정수 0 or 1을 비교함. 
		- char 같은거 대신 쓰는 이유는 가독성/유지보수성 때문에 사용한다고 보면 됨.
	- 부동소수점(floating-point)
		- IEEE 754 표준 참고
		- 소수점 위치가 고정되지 않는 숫자
		- 데이터 크기 대비 큰 범위를 표시 가능
		- 단 값의 누락 발생, 근사값임. `==` 시 주의, 반복 연산 시 늘어나는 오차범위 주의
		- float(4바이트, 6~9자리까지 유효), double(8바이트, 소수점 15~17자리까지 유효)
		- GPT 정리
			- **지수 (Exponent)**: 숫자의 크기를 조정하며, 2의 지수승으로 표현됩니다.
			- **가수 (Mantissa)**: 숫자의 정밀도를 나타내며, 1.xxxx 형태로 저장됩니다.
			- **구조**: `float`과 `double`은 각각 1비트의 부호, 8/11비트의 지수, 23/52비트의 가수로 구성됩니다.
- 문자와 문자열
	- char: 내부적으로는 정수임. (더하기, 빼기 등 연산 가능) 근데 ASCII 문자랑 대응됨. 
		- 0~127를 넘는 값, 음수나 더 큰 값을 사용하면 이상한 문자가 출력됨. 
	- Unicode -> UTF8,UTF16 장단점 - 위에 설명 있음. 아니면 검색하던가
	- 문자열: 문자 배열, string 자료형은 문자 배열 + 문자열 관련 기능 추가 
		- char 배열의 마지막에는 끝임을 알리기 위해서 00(NULL)이 있어야 함.
- 산술 연산
	- `=`, `()`, `+, -, *, /, %`, `+=, -=, %=, /=`, `++, --`(이거는 `++a` 처럼 앞에 있는게 약간 빠름)
- 비교/논리 연산
	- 특정 조건/상태 확인
	- [불 대수](https://ko.wikipedia.org/wiki/%EB%B6%88_%EB%8C%80%EC%88%98)
	- 단락 평가(short-circuit evaluation): 조건문 만족하면 나머지 스킵하는 거
		- 어셈블리어 까서 보여줌.
- 비트 연산
	- `~(not), &, |, ^(xor), <<, >>`
		- `1 << 3` 1을 3번 왼쪽(<<)으로 시프트
	- C++에서 시프트
		- 왼쪽 시프트 (<<)
			- **모든 타입에 대해 논리적 시프트**: 비트를 왼쪽으로 이동시키고, 오른쪽에 0을 채웁니다.
			- 부호 있는 정수에서도 논리적 시프트를 사용하지만, 이는 부호 비트가 이동될 수 있음을 의미하며, 결과적으로 값의 부호가 바뀔 수 있습니다.
		- 오른쪽 시프트 (>>)
			- **부호 없는 정수 (unsigned integers)에 대해 논리적 시프트**: 비트를 오른쪽으로 이동시키고, 왼쪽에 0을 채웁니다.
			- **부호 있는 정수 (signed integers)에 대해 산술적 시프트**: 비트를 오른쪽으로 이동시키고, 왼쪽에 부호 비트(기존 최상위 비트 값)를 채웁니다. 대부분의 컴파일러에서 부호 있는 정수에 대해 산술적 시프트를 수행합니다.
				- 음수(앞이 1)를 >> 하는 경우 1001이면 1100이 된다.
				- 부호에 따라서 0/1 여부가 달라짐.
	- BitFlag: Bit로 상태(Flag) 표시
	- BitMask: BitFlag의 원하는 값을 뽑아내는 Mask
- const와 메모리 구조
	- const: 초기화와 할당이 동시에 수행, 수정 불가능
		- 특정 하드코딩된 값에 문맥을 제공해줄 수 있음.
	- 메모리 구조
		- .data: 초기화된 고정(전역, 상수)
		- .bss: 초기화 안된 전역. (그 외 있을 수도?)
		- .rodata: 읽기 전용 영역 (const pointer 등)
		- stack: 지역변수, 콜스택
		- heap: 동적 영역
		- 메모리 영역에 대한 구체적인 C++의 표준이 없음. 정확한건 컴파일러 하기 나름.
- 유의사항
	- 변수의 유효범위: 같은 변수 이름을 사용하는 경우 등
		- 이름 변경, `{}`를 사용한 스코프 제한 등
	- 연산 우선순위: 가독성, 명확성을 위해 `()` 사용하기
	- 타입 변환: 
		- 작은 범위와 넒은 범위의 연산 시 넒은 범위로 변환 (암시적 형변환)
		- (특히 int와 float는 둘다 같은 바이트지만 float는 더 넒은 범위 표현이 가능하므로 변환됨)
		- 큰 범위를 작은 범위로 변경하는 경우 데이터 분실 주의 (상위 비트 그대로 없어짐)
		- signed, unsigned 사이 간 연산 주의
	- 연산
		- 0으로 나누기
		- 오버/언더플로우
		- 부동소수점 정밀도
### 코드의 흐름 제어
- 분기문
	- 꼭 true(1)이나 flase(0)이 아니여도 됨. 0이 아니면 true로 판단함.
	- `if-else, switch-case`
		- `switch-case`는 특정(연속된(gap이 적은) 상수 값, Enum) 경우 점프 테이블을 생성해 O(1)로 효율적이다.
			- 아닌 경우 `if-else`와 비슷하게 동작함.
- 반복문
	- `while, do-while, for`
	- `continue, break`
- 연습문제(별찍기와 구구단) & 가위바위보
	- 간단한 입출력 문제 구현
	- 컴퓨터의 rand는 구현하기 어렵다. 사실 대부분의 rand 기능은 정말 "랜덤"하다고 보기 어렵다. seed 값을 설정하는 식인데, 이걸 매번 바뀌는 컴퓨터의 상태 or 시간 정보를 가공해서 예측하기 어렵게 한다.
- 열거형
	- `enum`
		- 컴파일 시점에 상수 int로 변경
		- 숫자를 지정 안하면 0부터 시작
			- 다음 숫자는 이전숫자 + 1
		- `0, 1, 2, 0(0으로 설정), 1, 2` 같은 경우도 됨.
			- 이 경우 0번째 값과 3번째 값이 동등(`==`)하게 처리됨.
			- 그냥 숫자 0이랑 비교해도 됨.
			- enum의 내부 동작을 이해하는 용도로, 실제로는 관리가 어려우므로 추천하는 방식은 아님.
	- define 매크로
		- enum 역할을 이걸로도 수행 가능.
		- 그러나 매크로는 추천하지 않는다는 내용.
		- 그대로 대체하는 것이라서 연산자 우선순위 등을 고려하지 않음.
			- enum 대비 IDE의 지원을 받기 어려움
### 함수
- 함수 기초
	- 정리할거 딱히 없음
- 스택 프레임
	- 어셈블리어에서 이미 다루기도 했고, 알고 있는 내용이므로 스킵
	- 구조 - 높은 곳 -> 낮은 곳으로 늘어남
		- (높은 곳)
		- 매개변수 - 0번째
		- 반환주소 - 1번째
		- 지역변수 - 2번째
		- (낮은 곳)
- 지역 변수와 값 전달
	- 지역변수: 스택에 올라감, 콜스택 끝나면 유효하지 않음.
	- 전역변수: 다른 영역(data, bss 등)에 들어감. 모든 영역에서 접근/변경 가능하므로 사용에 주의
	- 값 전달: 스택에 값 자체를 넘겨주므로 호출자에게 영향이 가지 않음.
		- call by value/reference 관련 내용
		- 나는 따지고 보면 포인터도 값이라고 생각하는데, 포인터를 포함해서 조금 특별한 값 들을 reference라고 정의한다고 생각하고 있음.
- 호출(콜) 스택
	- 함수 선언: 함수 간의 호출을 쉽게하기 위해서 함수의 시그니처를 미리 정의해 주어야 한다.
	- 호출 스택
		- 호출 스택을 통해서 특정 함수가 어떤 함수로부터 호출되었는지 확인 가능.
		- 디버거에서 호출 스택 정보를 확인할 수 있다.
- 함수 마무리
	- 오버로딩 (C는 지원 안하는데 C++은 지원함)
		- 반환 형식과 이름이 같은 함수(시그니처(파라미터 개수, 타입)가 다름)가 여러개
		- 근데 이거 [씹어먹는 C++](https://modoocode.com/135)보면 더 자세함. (대충 자동으로 끼워 맞출 수 있는 타입이면 형변환해서 끼워준다는 내용)
	- 함수 기본값
		- 기본값이 설정된 매개변수가 맨 끝쪽에 있어야 함.
		- 대신 named parameter 처럼 자유롭지는 않음.
	- stack overflow
		- 스택 프레임이 너무 많이 쌓여서, 컴파일 시점에 정해짐 스택 영역이 다 차버려서 더 호출을 못하면 발생하는 에러
- TextRPG
	- https://gist.github.com/YangSiJun528/d6dd3e4f8d43d31250e51189f9ec1359 에 만든거 정리
	- 간단한 텍스트 게임.
	- 구조체를 사용한 개선
		- 구조체는 모두가 같은 타입이 아닐 때, 패딩이 생겨서 더 큰 크기를 가진다. (컴퓨터가 계산하기 쉽게 함, 컴파일러에 따라 차이가 있을 수 있음 == 표준이 아님)
	- 클래스의 필요성을 보여주는 부분인듯?
### 포인터
- 포인터의 필요성
	- 변수: 어떤 값을 특정한 이름으로 담아서 관리하는 거. 
		- 컴파일 이후에는 변수라는 개념이 딱히 없음. data 영역 등의 메모리 주소나 stack(이것도 메모리 주소긴 함)에 값이 저장되어 동작하도록 만들어짐
	- 포인터의 필요성
		- 함수 호출 시 원본 데이터의 수정이 필요한 경우.
		- 메모리 효율적으로 값을 다루기 위함. 
			- 구조체 등에서 데이터 자체를 넘기면 데이터가 stack에 복사됨.
			- return 해서 변경된 값을 받는 식으로도 간접적으로 원본 수정 가능한데, 이러면 구조체 크기가 크면 전부 복사해야함. 호출자가 결과를 다시 수정해야 하므로 연산이 늘어나고 비효율적.
- 포인터
	- 특정 자료형의 주소를 가리키는 변수
	- 포인터를 통해서 실제 변수에 접근해서 값을 수정할 수도 있음. (간접참조?)
	- 어셈블러 동작 방식을 보면 이해하기 쉬움.
	- 컴퓨터 환경에 따라서 4byte(32bit) or 8byte(64bit)
	- 타입
		- 읽어야 할 메모리 범위를 알려주기 위해서 필요함. (int는 4byte이므로 4byte만큼 읽어야 함.)
	- 포인터를 사용해서 데이터를 잘못 다루면 다뤄야 할 범위를 넘어서 다른 기존 데이터에 영향을 줄 수 있음.
	- const 사용법
		- `const 타입 *이름`: 포인터를 불변으로. 즉, 참조하는 대상(포인터의 값)을 변경할 수 없음.
		- `타입 const *이름`:  `이름`을 불변으로. 즉, 참조하는 대상의 값을 변경할 수 없음.
		- 둘 다 사용하는 것도 가능.
- 포인터 연산
	- +, - 시에는 자료형 크기만큼 증감함. 그게 자연스러움. 다음 데이터가 있을 위치로 이동. 배열을 사용할 떄 필수로 씀.
	- `*(용도 다양), &, ->`
- 포인터 실습
	- 내용 자체는 스킵
	- 구조체를 복사하는 방식(어셈블리어를 읽고, 메모리 낭비나 연산 많은 문제를 보여줌)을 포인터를 사용하는 식으로 개선
- 참조(reference) 기초 
	- C에는 없고 C++에서 추가된 개념
	- 내부적으로는 포인터와 동일하게 동작함.
		- ![](Pasted%20image%2020240626214455.png) 이미지를 보면, 어셈블리어 변환 결과 포인터와 참조의 동작이 동일한 걸 알 수 있다.
		  어셈블리 코드에서는 `pointer` 가 스택의 `[sp + 16]` 위치에 8바이트 크기로 저장되는 모습을 볼 수 있는 반면,  `reference`는 별도의 메모리 공간을 차지하지 않고, `number`의 메모리 주소를 그대로 사용함.
	- 메모리 상에 존재하지 않는다. 단, 함수의 파라미터로 받는 경우, 포인터와 동일하게 메모리 공간을 가진다. (함수 호출 시에는 주소 값을 넘겨줘야 해서 callee 입장에서는 포인터나 참조 변수나 동일하게 동작하는건데, 이건 뭐... 레퍼런스 자체라기 보다는 함수 호출이나 파라미터의 특징 아닌가? 그래도 메모리 상에 존재하게 되는거긴 하니까...?)
	- 레퍼런스는 초기 선언이 필수적이며, 다른 대상을 참조할 수 없다.
		- 레퍼런스가 메모리 상에 존재하지 않기 떄문에, 항상 참조하는 변수의 값이 선언되어 있어야 한다.
		- 이런 특징을 보장하기 위해 포인터, 배열, 리터럴을 사용할 수 없는 것이다. (포인터는 값이 유효하지 않을 수 있고, 리터럴은 변수가 아니니까)
	- (리터럴, 배열, 포인터, 레퍼런스)를 제외한 변수의 레퍼런스를 사용할 수 있다.
		- 특정 변수를 참조하는 변수. 참조하는 것이기 때문에, 어셈블리어 입장에서는 별도의 변수라기보다는 그 변수 자체이다. 
		- const를 사용해서 값을 수정하지 않게 할 수 있음. (사용할 수 있으면 무조건 쓰기)
	- 나는 포인터를 사용하게 쉽게 해주는 목적으로 사용된다고 이해함.
		- 근데? 포인터와 달리 별도의 메모리 공간 대신, 변수의 메모리를 그대로 사용하는...
		- 포인터 사용 시, `->`나 `*`를 사용하는 접근이 불편하기 때문.
	- 특정 변수의 참조(`int& r = int_val`). 변수처럼 다루는데, 실제로는 `int_val`이 변경됨.
	- 주의점
		- 참조하는 대상이 사라지는 댕글링 레퍼런스 (Dangling reference) 발생 주의
			- 예시: 지역변수 a를 참조하는 레퍼런스(참조자) b를 리턴. 호출자로 돌아온 시점에서 a가 만료되었으므로 리턴받은 b에 접근하면 런타임 에러 발생
	- const를 사용해서 해당 참조하는 대상을 수정할 수 없게 가능.
	- 씹어먹는 C++의 설명: https://modoocode.com/141
- 포인터 vs 참조
	- 성능: 비슷함
	- 사용성: 참조가 더 편함
	- 주의점: 그럼에도 편의성이 좋은게 꼭 좋은건 아니다.
		- 긴 코드의 경우, 코드만 보고 일반 타입인지, 레퍼런스 타입인지 모름.
	- 초기화: 참조는 항상 유효한 값을 가지고 있어야 함. (실무에서는 nullptr 등으로 값을 반환하기도 하는데, 이런게 안됨. 근데 이런건 result 같은걸 쓰는게 좋지 않나 싶은데, 현실적으로는 그게 어려우니까)
	- 결론: 케바케, 구글은 거의 안쓰고, 얼리얼은 쓴다. 성능 차이가 없다시피 하니까 그냥 팀 따라서 별 차이 없는듯.
	- 강사 피설: 본인은 참조 + define으로 수정 가능한 함수임을 명시적으로 구분하는걸 선호한다고 함. 수정 안되면 const
- 배열 기초
	- 동일한 여러 데이터를 연속된 메모리 구조에 순차적으로 저장.
		- 동일한 타입의 여러개를 하나로 묶어서 관리하기 위함.
	- 배열의 이름 시작 주소를 바라보는 포인터라고 볼 수 있음.
		- 어셈블러 코드랑 메모리 디버깅 해서 확인 가능.
		- 함수로 값을 넘길때도, 포인터와 동일하게 call by references
	- > `arr[i]` 와 같은 문장은 사실 컴파일러에 의해 `*(arr + i)` 로 변환된다.
		- 출처: https://modoocode.com/25
	- char 배열, 여러 초기화 기법 등 설명은 생략
	- 문자열(`"`)도 사용하기 쉽게 만들어진 배열, 내부적으로는 char 배열과 동일하게 구성.
- 포인터 vs 배열
	- 포인터: 주소를 담는 바구니
	- 배열: 바구니의 모음 그 자체. 연속된 메모리 공간
		- 다만, "배열 이름"은 바구니 모음의 "시작 주소"(포인터)
		- 즉, 배열 이름은 포인터지만, 배열은 포인터가 아니다.
		- 배열을 연속된 메모리를 가지는 실체이므로, 사용 시 큰 데이터를 가지고 있다는 걸 알아야 한다.
- 로또 번호 생성기
	- 정렬(n^2), swap, 랜덤 번호 생성, 총 3가지 기능을 사용해서 구현.
- 다중 포인터
	- 다중 포인터의 필요성
		- 포인터 변수를 넘겨줘서 포인터 변수의 값을 수정하고 싶은 경우.
		- 즉 포언터 변수의 주소 값을 저장해야 하는 상황에서 필요
- 다중 배열
	- 내부적으로 1차원 메모리처럼 동작함. (`[]`를 사용하는, C++의 기본 기능 기준)
		- 참고: https://modoocode.com/20
	- 어셈블리어의 물리적인 1차원 배열을 C++에서 논리적으로 N차원 배열로 구분하는 느낌.
- 포인터 마무리
	- 포인터 VS 배열 ver  - 포인터와 배열은 다르다.
		- 1중 포인터와 1차원 배열은 상호 호환이 된다.
			- 서로 변환하며 사용할 수도 있고, "배열의 이름"이 포인터이기 때문이다.
		- 2중 포인터와 2차원 배열은 다르다. (2중 이상인 N중 포함)
			- 2중 포인터는 연속된 공간이 아니라, 독립된 공간이 주소를 타고 타고 접근 가능. 
			- 2차원 배열은 내부적으로 1차원 배열로, 연속된 공간을 가진다.
	- 포인터 사용 시 주의점
		- C++은 메모리에 접근하고 수정 가능함. 강력하지만 너무 위험하다.
			- 잘못 수정하면 이 부분을 찾기가 너무 어렵다.
			- 강사 피셜: MMORPG에 신입으로 일을 했었는데, 7년 전에 짜놓은 코드에 문제가 있었고 그걸 건드려서 일주일간 계속 크래시가 났었다.
- TextRPG
	- 이전에 만든거 구조체 + 포인터 사용해서 로직 개선
	- 포인터 실제 예시 설명을 위함인 듯?
- 연습문제
	- 문자열 관련 함수 구현
		- 문자 배열 다룰 때 주의 할 부분. 길이, 비교 확인 연산 등
	- 여담
		- strcpy는 의도하지 않은 메모리를 다룰 수 있어서(잠재적 에러 상황), 조기에 에러를 발생시키는 strcpy_s를 사용하는게 좋다.
		- 포인터끼리의 == 연산은 주소값이 동일한지 비교한다. 
	- 달팽이
		- 간단한 코테? 구현 문제 풀이함.
- 파일 분할 관리
	- cpp, h 파일 사용법. 함수 중복 정의 문제나 그런거 주의하라는 내용. .h 의 정의가 중복되는 문제와 그 해결 (`#pragma once`, 근데, CLion에서는 `#ifdef`사용하는 거 같음. 아마 `#pragma`는 공식 문법이 아니라 그런듯?)
	- 씹어먹는 시리즈가 더 설명 잘해줘서 그거 보는게 더 나을듯.
- 