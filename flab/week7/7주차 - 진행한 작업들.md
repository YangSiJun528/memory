

### 이미지 업로드 기능 구현

(처음 구현해보는 기능이라 시행착오가 좀 있었다.)

NCP 공식문서를 확인해보니 AWS SDK를 사용해서도 가능하다고 하였다.

이전에 프로젝트에서 AWS로 S3에 이미지를 업로드 할 때, `io.awspring.cloud`의 스프링과 AWS를 쉽게 사용할 수 있도록 해주는 라이브러리를 사용한 경험이 있었고.

해당 라이브러리를 사용하면 편리하게 구현할 수 있다고 생각했다.

자료를 찾아보니 [2년전 자료](https://velog.io/@whitebear/Spring%EC%97%90%EC%84%9C-Naver-Cloud-Object-Storage-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%97%90%EB%9F%AC-%EC%82%AC%EB%83%A5%ED%95%98%EA%B8%B0)고 의존성이 다르긴 하지만 가능하다는 걸 확인하였다.

(저 자료에서 주의해야 할게, 오류 수정 부분이다. NCP가 AWS 리전을 매핑해서 처리하는게 아닌가 싶은데, 이유가 명확하지 않다.)

더 자세히 설명하자면 위 자료에서는 `org.springframework.cloud`를 사용하는데, 어차피 동일한 코드 기반으로 `io.awspring.cloud`가 최신 코드라고 볼 수 있어서, 작업에는 큰 문제가 없을 것 같다고 생각했다.


[awspring 공식문서](https://docs.awspring.io/spring-cloud-aws/docs/3.1.0/reference/html/index.html#configuring-credentials)를 보고 커스텀 옵션을 사용하여 정의하였다.

> The starter automatically configures and registers a `S3Client` bean in the Spring application context.

그러므로 `S3Client` Bean을 재정의하면 NCP에서도 동작하게 할 수 있을 것 같다고 생각함


##### 문제 발생 - `Region` 정해진 값만 사용 가능

다음과 같이 코드를 구현하고 있었다.
```java
@Configuration  
@RequiredArgsConstructor  
public class NcpConfig {  
  
    private final NcpProperties properties;  
  
    @Bean  
    public S3Client ncpS3Client() {  
        AwsBasicCredentials credentials = AwsBasicCredentials.create(this.properties.getAccessKey(), this.properties.getSecretKey());  
  
        return S3Client.builder()  
                .credentialsProvider(StaticCredentialsProvider.create(credentials))  
                .endpointProvider()  
                .build();  
    }  
  
}
```

그런데 region을 string으로 입력할 수 없었다. `Region` 정해진 상수만 입력 받을 수 있는 것이였는데,

```java
@SdkPublicApi  
@Generated("software.amazon.awssdk:codegen")  
public final class Region {  
    public static final Region AP_SOUTH_2 = Region.of("ap-south-2");  
  
    public static final Region AP_SOUTH_1 = Region.of("ap-south-1");
  ...
}
```

[NCP 공식문서](https://guide.ncloud-docs.com/docs/storage-storage-8-1)를 보니 AWS Java SDK 1.11.238 버전을 사용하고 있었다.

하지만 내가 현재 사용하는 `io.awspring.cloud:spring-cloud-aws-starter-s3`의 버전은 `3.1.1`이고 해당 라이브러리는 `software.amazon.awssdk`(AWS Java SDK) 2.21.46 버전을 가지고 있었다.

이제 2가지 선택지로 나뉘어졌다.

1. 공식문서대로 AWS Java SDK 1.11.238 사용해서 개발하기
2. AWS Java SDK 1.xx 대 버전을 지원하는 `io.awspring.cloud`를 도입하기
3. [2년전 자료](https://velog.io/@whitebear/Spring%EC%97%90%EC%84%9C-Naver-Cloud-Object-Storage-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%97%90%EB%9F%AC-%EC%82%AC%EB%83%A5%ED%95%98%EA%B8%B0)처럼 리전을 AWS의 `ap-northeast-2`로 설정하기
	1. 왜 되는지 이유가 명확하지 않아서 고려 안함

우선 1번 선택지인 AWS Java SDK 자체를 사용하는 게 더 나을거 같긴 하지만, 코드가 너무 low하고, 더 깔끔한 코드를 작성하고 싶어서 2번을 먼저 시도해보기로 했다.

단, 보안 문제가 발생할 수 있으므로(AWS 관련된 `org.springframework.cloud`만 해도 2020년대 코드인데, 취약점이 있다고 stackoverflow에서 봤던 기억이 있다.) 너무 버전이 오래되었으면 사용하지 않기로 하였다.

https://mvnrepository.com/ 에 접속해서 [Spring Cloud AWS S3](https://mvnrepository.com/artifact/io.awspring.cloud/spring-cloud-aws-s3)의 각 버전 별로 `software.amazon.awssdk` 버전을 확인해보았는데, 가장 낮은 버전도 2.xx대로 시작해서, 2번 방식은 어렵게 되었다.

###### 해결(문제 분석을 잘못함) - Region 문자열로 사용 가능함

혹시 몰라서 코드를 다시 확인하는 중에, `of` 메서드를 제공하는 것을 확인하였다.
문자열로 사용할 수 있었다. 

혼자 삽질한 거지만, 문자열을 사용하는 것으로 문제를 해결하였다. 


#### 환경변수 관리하기

아래처럼 구현하였는데, 프로퍼티 값이 불변이 아니라 불만이였다.
```java
@Getter  
@Setter  
@Configuration  
@ConfigurationProperties(prefix = "ncp")  
public class NcpProperties {  
  
    private String endPoint;  
  
    private String region;  
  
    private String accessKey;  
  
    private String secretKey;  
  
    private String bucketName;  
  
}
```

이전에 불변으로 했던 것 같아 문서를 찾아봄. [벨덩](https://www.baeldung.com/configuration-properties-in-spring-boot) 문서에서 record를 사용해서 가독성 좋게 구현한 걸 보고 적용

```java
@Configuration  
@EnableConfigurationProperties({ NcpProperties.class })  
@RequiredArgsConstructor  
public class NcpConfig {  
  
    private final NcpProperties ncpProperties;  
  
    @Bean  
    public S3Client customS3Client() {  
        AwsBasicCredentials credentials = AwsBasicCredentials.create(this.ncpProperties.accessKey(),  
                this.ncpProperties.secretKey());  
  
        return S3Client.builder()  
            .credentialsProvider(StaticCredentialsProvider.create(credentials))  
            .region(Region.of(this.ncpProperties.region()))  
            .endpointOverride(URI.create(this.ncpProperties.endPoint()))  
            .build();  
    }  
  
}
```

불변으로 사용하기 위해서 `@EnableConfigurationProperties`도 추가, 다른 예시에선 메인 클래스에 입력하는 것 같은데, 나는 해당 패키지의 구성이 모이는 `NcpConfig`에 설정하였다. 

그리고 프로퍼티 값을 담은 `NcpProperties`는 레코드를 사용해서 아래처럼 되었다.
```java
@ConfigurationProperties(prefix = "ncp")  
public record NcpProperties(  
        String endPoint,  
        String region,  
        String accessKey,  
        String secretKey,  
        String bucketName  
) {  
}
```

#### Object Storage AccessDenied 문제
이미지를 정상적으로 올렸지만, 주소를 접근해보니 AccessDenied가 발생한다.

[공식문서](https://api.ncloud-docs.com/docs/storage-objectstorage)와 구글링을 통해 원인을 파악하였다.

ACL 설정을 하지 않았고, 이로 인해 NCP 권한 있는 사용자만 접근 가능했다.

나는 `io.awspring.cloud`를 사용하므로 이미 해당 문제와 관련된 옵션이 있을 꺼라 생각해서 `S3Template` 소스 코드를 보니 `ObjectMetadata`로 메타데이터 값을 지정해 줄 수 있다는 것 알았다.

```java
S3Resource s3Resource = this.s3Template.upload(this.ncpProperties.bucketName(), createFileName(fileExtension),  
        getInputStream(resource), ObjectMetadata.builder().acl(ObjectCannedACL.PUBLIC_READ).build());
```
파일을 업로드하는 코드에 `ObjectMetadata`의 필드 값으로`ObjectCannedACL.PUBLIC_READ`을 추가하여 해결하였다.

#### 통합테스트 로직에서 파일이 삭제되지 않는 문제

`ImageUploadServiceImpl`이 잘 동작하는지 확인하기 위해 다음과 같은 테스트코드 작성

```java
@Test  
void shouldUploadImage() {  
    // 애플리케이션 시작 시 실행되는 로직  
    String fileLocation = "내 로컬 아무 이미지 경로"
    Resource resource = new FileSystemResource(fileLocation);  
    String result = this.service.execute(resource);  
  
    System.out.println(result);  
    assertNotNull(result);  
    String filename = StringUtils.getFilename(result);  
    
	// test가 성공했으므로 필요없는 데이터는 삭제  
    template.deleteObject(ncpProperties.bucketName(), filename); 
}
```

외부 서비스라서 트랜잭션 롤백 같은게 안 되서, 테스트하고 성공하면 삭제하는 로직을 작성하였다.

그런데 실제로 버킷을 확인해보면 이미지가 삭제되지 않고 남아있음

실제 파일 이름은 `976a6178-f538-4bce-8856-ba8ef84639a52024-04-07T15:36:41.820229.png`이런 식인데, 내가 작성한 로직에서는 `976a6178-f538-4bce-8856-ba8ef84639a52024-04-07T15%3A36%3A41.820229.png`처럼 나와서 이름이 달라 삭제가 되지 않았다.

딱 봐도 URL Encoding 때문이라 `StringUtils.uriDecode`를 사용하도록 수정하였다.

```java
String filename = StringUtils.getFilename(StringUtils.uriDecode(result, StandardCharsets.UTF_8));
```

디버깅 해보니 `filename` 값이 잘 나오고, 삭제도 잘 되었다.

아래는 디버깅에서 나온 변수 값.
```
filename = "976a6178-f538-4bce-8856-ba8ef84639a52024-04-07T15:36:41.820229.png"  
result = "https://celog-bucket.kr.object.ncloudstorage.com/976a6178-f538-4bce-8856-ba8ef84639a52024-04-07T15%3A36%3A41.820229.png"
```

### Spring 통합테스트 환경 / Product 환경 설정하기

#### Gradle 환경에서 Docker Compose Support 사용해 통합 테스트하기
나는 스프링 부트 3.1 버전 부터 지원하는 [Docker Compose Support](https://docs.spring.io/spring-boot/3.3/reference/features/docker-compose.html) 기능을 사용해서 로컬 환경에서 개발하고 있었다.

다만 이 경우 test 환경에서 실행되지 않는 문제가 있었다. 공식문서에선 `spring.docker.compose.skip.in-tests` 값을 설정해야 한다고 하는데, 그렇게 동작해도 실패한다.

구글링을 해 보니 이 문제를 해결한 [블로그 자료](https://medium.com/@jugurtha.aitoufella/facilitate-your-integration-tests-with-spring-docker-compose-31963469e789)를 보았다. Maven이지만 의존성의 범위를 test로 늘린 것인데, 공식문서에는 이러한 설정이 없어서 쉽지 않았다.

또 공식문서의 Maven과 Gradle의 의존성을 가져오는 코드가 달랐다. Gradle은 `developmentOnly`로 가져오는데, Maven은 그런거 없이 `optional`만 설정하고 있다. 그래서 내가 Maven으로 개발을 했으면 이런 문제는 없었을 것 같다.

그래서 공식 깃허브에 이슈로 제출하려고 했는데, 아쉽게도 3일 전에 누가 미리 [제안](https://github.com/spring-projects/spring-boot/issues/40171)을 올렸다.


### Infra 구축하기

k8s도 사용해볼까 했지만, CD도 ArgoCD라는 걸 사용하는 걸 권장하는 것 같고, 실제로 운영하는데 있어서 선행되어야 할 작업이나 (문제 해결을 위한) 공부가 많이 필요해 보여서 포기하였다.

그리고 ELB나 무중단배포도 생각해봤는데, 배워가면서 하면 가능할 것 같긴 하지만, 이거에만 일주일 넘게 투자해야 할 거 같아서 마찬가지로 포기.

우선 서버 인스턴스 하나 띄우고, CICD 적용하고, 성능테스트 & 개선을 목표로 함

그래서 spring 어플리케이션 인스턴스, redis 인스턴스, mysql 인스턴스 총 3개로 구성.

따로 FE 부분은 구현하지 않았다.

실행 결과를 바깥에서도 확인하고 싶어서 public하게 접근하도록 수정하고 있다.

아니 근데 레디스가 안되;;;; ㅅㅂ 조까 안해

```
MYSQL
username: sijun193f908dfs
port: 12306
pw: o1kciw@pqw@kc@p23
name:celog
```


근데 어차피 성능테스트하고 배치 하려면 써야하는거 아님?

mysql은 public ip로 설정



### CD 구현하기

Github Actions를 사용하고, 인터넷에 나온 가장 간단한 방식으로 하기로 했다.

1. 도커 이미지 빌드하고 이미지 레지스트리에 저장
2. 서버 인스턴스에 직접 SSH 보내서 이미지 풀 받고 인스턴스 재시작하기

서버가 public subnet에 위치하게 되서 별로 좋은 방식은 아니라고 생각한다. 또 여러 서비스가 있으면 여러 서비스에 보내줘야 하므로 불편할 것 같다.

다만 실제 서비스를 운영하는게 아니고, 빠르게 구현해보는게 목적이므로 간단하게 구현하기로 했다.

만약 실제 서비스를 개발했다면, ELB, Auto Scaling, AWS CodeDeploy(NCP SourceDeploy) 같은 조합으로 사용하는게 가장 좋지 않을까 싶다. 아니면 쿠버네티스를 사용하거나.



